
Atmega8535.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000009c4  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000a38  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000017  00800060  00800060  00000a38  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000a38  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000a68  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000088  00000000  00000000  00000aa8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000022ef  00000000  00000000  00000b30  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000078b  00000000  00000000  00002e1f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000bd7  00000000  00000000  000035aa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000148  00000000  00000000  00004184  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000a7a  00000000  00000000  000042cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000c4a  00000000  00000000  00004d46  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000e0  00000000  00000000  00005990  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	15 c0       	rjmp	.+42     	; 0x2c <__ctors_end>
   2:	a0 c4       	rjmp	.+2368   	; 0x944 <__vector_1>
   4:	b3 c4       	rjmp	.+2406   	; 0x96c <__vector_2>
   6:	2c c0       	rjmp	.+88     	; 0x60 <__bad_interrupt>
   8:	2b c0       	rjmp	.+86     	; 0x60 <__bad_interrupt>
   a:	2a c0       	rjmp	.+84     	; 0x60 <__bad_interrupt>
   c:	29 c0       	rjmp	.+82     	; 0x60 <__bad_interrupt>
   e:	28 c0       	rjmp	.+80     	; 0x60 <__bad_interrupt>
  10:	27 c0       	rjmp	.+78     	; 0x60 <__bad_interrupt>
  12:	26 c0       	rjmp	.+76     	; 0x60 <__bad_interrupt>
  14:	25 c0       	rjmp	.+74     	; 0x60 <__bad_interrupt>
  16:	24 c0       	rjmp	.+72     	; 0x60 <__bad_interrupt>
  18:	23 c0       	rjmp	.+70     	; 0x60 <__bad_interrupt>
  1a:	22 c0       	rjmp	.+68     	; 0x60 <__bad_interrupt>
  1c:	21 c0       	rjmp	.+66     	; 0x60 <__bad_interrupt>
  1e:	20 c0       	rjmp	.+64     	; 0x60 <__bad_interrupt>
  20:	1f c0       	rjmp	.+62     	; 0x60 <__bad_interrupt>
  22:	1e c0       	rjmp	.+60     	; 0x60 <__bad_interrupt>
  24:	1d c0       	rjmp	.+58     	; 0x60 <__bad_interrupt>
  26:	cf c3       	rjmp	.+1950   	; 0x7c6 <__vector_19>
  28:	1b c0       	rjmp	.+54     	; 0x60 <__bad_interrupt>

0000002a <__ctors_start>:
  2a:	ca 04       	cpc	r12, r10

0000002c <__ctors_end>:
  2c:	11 24       	eor	r1, r1
  2e:	1f be       	out	0x3f, r1	; 63
  30:	cf e5       	ldi	r28, 0x5F	; 95
  32:	d2 e0       	ldi	r29, 0x02	; 2
  34:	de bf       	out	0x3e, r29	; 62
  36:	cd bf       	out	0x3d, r28	; 61

00000038 <__do_clear_bss>:
  38:	20 e0       	ldi	r18, 0x00	; 0
  3a:	a0 e6       	ldi	r26, 0x60	; 96
  3c:	b0 e0       	ldi	r27, 0x00	; 0
  3e:	01 c0       	rjmp	.+2      	; 0x42 <.do_clear_bss_start>

00000040 <.do_clear_bss_loop>:
  40:	1d 92       	st	X+, r1

00000042 <.do_clear_bss_start>:
  42:	a7 37       	cpi	r26, 0x77	; 119
  44:	b2 07       	cpc	r27, r18
  46:	e1 f7       	brne	.-8      	; 0x40 <.do_clear_bss_loop>

00000048 <__do_global_ctors>:
  48:	10 e0       	ldi	r17, 0x00	; 0
  4a:	c6 e1       	ldi	r28, 0x16	; 22
  4c:	d0 e0       	ldi	r29, 0x00	; 0
  4e:	03 c0       	rjmp	.+6      	; 0x56 <__do_global_ctors+0xe>
  50:	21 97       	sbiw	r28, 0x01	; 1
  52:	fe 01       	movw	r30, r28
  54:	af d4       	rcall	.+2398   	; 0x9b4 <__tablejump2__>
  56:	c5 31       	cpi	r28, 0x15	; 21
  58:	d1 07       	cpc	r29, r17
  5a:	d1 f7       	brne	.-12     	; 0x50 <__do_global_ctors+0x8>
  5c:	43 d0       	rcall	.+134    	; 0xe4 <main>
  5e:	b0 c4       	rjmp	.+2400   	; 0x9c0 <_exit>

00000060 <__bad_interrupt>:
  60:	cf cf       	rjmp	.-98     	; 0x0 <__vectors>

00000062 <_Z15port_initializev>:
#include "termoreg.h"
#include <avr/interrupt.h>

void port_initialize(void)                 /* Иниализация портов ввода-вывода */
{
	PORTA |=  (1 << PA1) | (1 << PA2) | (1 << PA3) | (1 << PA4) | (1 << PA5) | (1 << PA6) | (1 << PA7); // PA1 - PA7 как вход c подтяжкой
  62:	8b b3       	in	r24, 0x1b	; 27
  64:	8e 6f       	ori	r24, 0xFE	; 254
  66:	8b bb       	out	0x1b, r24	; 27
	PORTA &= ~(1 << PA0);                                                                               // PA0 как вход без подтяжки
  68:	d8 98       	cbi	0x1b, 0	; 27
	DDRA  = 0x00;                                                                                       // Установка всех ножек PA на вход
  6a:	1a ba       	out	0x1a, r1	; 26
	
	PORTB = 0xFF;                                                                                       // Установка подтяжек всех ножек PB
  6c:	8f ef       	ldi	r24, 0xFF	; 255
  6e:	88 bb       	out	0x18, r24	; 24
	DDRB  = 0x00;                                                                                       // Установка всех ножек PB на вход
  70:	17 ba       	out	0x17, r1	; 23
	
	PORTD |=   (1 << PD0) | (1 << PD1) | (1 << PD2) | (1 << PD3);                                       // PD0 - PD3 как вход сподтяжкой
  72:	82 b3       	in	r24, 0x12	; 18
  74:	8f 60       	ori	r24, 0x0F	; 15
  76:	82 bb       	out	0x12, r24	; 18
	PORTD &= ~((1 << PD4) | (1 << PD5) | (1 << PD6) | (1 << PD7));                                      // PD4 - PD7 как выход
  78:	82 b3       	in	r24, 0x12	; 18
  7a:	8f 70       	andi	r24, 0x0F	; 15
  7c:	82 bb       	out	0x12, r24	; 18
	DDRD  |=   (1 << PD4) | (1 << PD5) | (1 << PD6) | (1 << PD7);                                       // PD4 - PD7 выход
  7e:	81 b3       	in	r24, 0x11	; 17
  80:	80 6f       	ori	r24, 0xF0	; 240
  82:	81 bb       	out	0x11, r24	; 17
	DDRD  &= ~((1 << PD0) | (1 << PD1) | (1 << PD2) | (1 << PD3));                                      // PD0 - PD3 как вход
  84:	81 b3       	in	r24, 0x11	; 17
  86:	80 7f       	andi	r24, 0xF0	; 240
  88:	81 bb       	out	0x11, r24	; 17
	
	PORTC |=   (1 << PC0) | (1 << PC1) | (1 << PC2) | (1 << PC7);                                       // PC0 - PC2, PC7 как вход с подтяжкой
  8a:	85 b3       	in	r24, 0x15	; 21
  8c:	87 68       	ori	r24, 0x87	; 135
  8e:	85 bb       	out	0x15, r24	; 21
	PORTC &= ~((1 << PC3) | (1 << PC4) | (1 << PC5) | (1 << PC6));                                      // PC3 - PC6 как выход
  90:	85 b3       	in	r24, 0x15	; 21
  92:	87 78       	andi	r24, 0x87	; 135
  94:	85 bb       	out	0x15, r24	; 21
	DDRC  |=   (1 << PC3) | (1 << PC4) | (1 << PC5) | (1 << PC6);                                       // PC3 - PC6 как выход
  96:	84 b3       	in	r24, 0x14	; 20
  98:	88 67       	ori	r24, 0x78	; 120
  9a:	84 bb       	out	0x14, r24	; 20
	DDRC  &= ~((1 << PC0) | (1 << PC1) | (1 << PC2) | (1 << PC7));                                      // PC0 - PC2, PC7 как вход
  9c:	84 b3       	in	r24, 0x14	; 20
  9e:	88 77       	andi	r24, 0x78	; 120
  a0:	84 bb       	out	0x14, r24	; 20
  a2:	08 95       	ret

000000a4 <_Z14ADC_initializev>:

void ADC_initialize(void)                  /* Инициализация АЦП */
{
	ADCSRA = (1 << ADEN)                     // Разрешение работы АЦП
	                                         // Одиночный режим работы (0 в разряде 5 ADFR в русском даташите)
	|(1 << ADPS2)|(1 << ADPS1)|(1 << ADPS0); // Делитель синхронизации работы АЦП на 128 (выбран максимальный делитель)
  a4:	87 e8       	ldi	r24, 0x87	; 135
  a6:	86 b9       	out	0x06, r24	; 6
	ADMUX = (1 << REFS0);                    // Опорное напряжение AVCC
  a8:	80 e4       	ldi	r24, 0x40	; 64
  aa:	87 b9       	out	0x07, r24	; 7
  ac:	08 95       	ret

000000ae <_Z31externalInterruption_initializev>:
} // конец ADC_initialize()

void externalInterruption_initialize(void) /* Инициализация внешних прерываний для статуса вентияляторов AF00 */
{
	MCUCR = (1 << ISC11)|(1 << ISC10)        // Установка прерывания по переднему фронту INT1
	|(1 << ISC01)|(1 << ISC00);              // Установка прерывания по переднему фронту INT0
  ae:	8f e0       	ldi	r24, 0x0F	; 15
  b0:	85 bf       	out	0x35, r24	; 53
  b2:	08 95       	ret

000000b4 <_Z10WDT_enablev>:
	// ВАЖНО: В русском даташите регистр таймера ОШИБОЧЕН с.48 MCUCR -> WDTCR (MCUCR регистр внешнх прерываний)
	
	/*То, в какой последовательности записывать биты в регистр, имеет значение
	Следуем рекомендациям для "уровня безопасности 2" на с.50 (В данном уровне отключение таймера НЕВОЗМОЖНО)
	*/
	cli();                                            // Запрещаем прерывания
  b4:	f8 94       	cli
	WDTCR = (1 << WDCE)                               // Разрешаем изменение периода сторожевого таймера
	|(1 << WDE);                                      // Разрешение работы сторожевого таймера
  b6:	88 e1       	ldi	r24, 0x18	; 24
  b8:	81 bd       	out	0x21, r24	; 33
	WDTCR |= (1 << WDP2) | (1 << WDP1) | (1 << WDP0); // Устанавливаем сброс по истечению 4.2 секунды
  ba:	81 b5       	in	r24, 0x21	; 33
  bc:	87 60       	ori	r24, 0x07	; 7
  be:	81 bd       	out	0x21, r24	; 33
	WDTCR &= ~(1 << WDCE);                            // Запрещаем изменение периода сторожевого таймера
  c0:	81 b5       	in	r24, 0x21	; 33
  c2:	8f 7e       	andi	r24, 0xEF	; 239
  c4:	81 bd       	out	0x21, r24	; 33
  c6:	08 95       	ret

000000c8 <_Z19counter0_initializev>:
} // конец WDT_enable()

void counter0_initialize(void) /* Инициализация таймера-счётчика 0 */
{
	TCCR0 = (1 << WGM01)        // Включаем режим СТС - сброс по совпадению
	|(1 << CS02) | (1 << CS00); // Включаем максимальный делитель на 1024
  c8:	8d e0       	ldi	r24, 0x0D	; 13
  ca:	83 bf       	out	0x33, r24	; 51
	OCR0 = 194;                 // Записываем число в регистр сравнения
  cc:	82 ec       	ldi	r24, 0xC2	; 194
  ce:	8c bf       	out	0x3c, r24	; 60
	/* формула на с.80 русского даташита:
	при делителе 1024, OCR0 = 194, F_CPU = 4МГЦ счётчик будет работать с периодом примерно 100 мс */
	TIMSK |= (1 << OCIE0);      // Разрешить прерывание по совпадению
  d0:	89 b7       	in	r24, 0x39	; 57
  d2:	82 60       	ori	r24, 0x02	; 2
  d4:	89 bf       	out	0x39, r24	; 57
  d6:	08 95       	ret

000000d8 <_Z14gettemperaturev>:
	/*
	АЦП в режиме одиночного преобразования, частота синхронизыции = 31250 кГц
	Результат записывается в 8ми битные регистры ADCH ADCL (c.217 русского даташита),
	однако эти регистры доступны как один 16ти битный ADC
	*/
	ADCSRA |= (1 << ADSC);             // Запуск преобразования. ADSC сбросится аппаратно в 0 после преобразования
  d8:	36 9a       	sbi	0x06, 6	; 6
	while (ADCSRA & (1 << ADSC)){};    // Ждём окончания преобразования : 13 тактов = 3.25 мкс
  da:	36 99       	sbic	0x06, 6	; 6
  dc:	fe cf       	rjmp	.-4      	; 0xda <_Z14gettemperaturev+0x2>
	return (int)ADC;                   // Возвращаем результат из регистров ADCH и ADCL
  de:	84 b1       	in	r24, 0x04	; 4
  e0:	95 b1       	in	r25, 0x05	; 5
	
}// конец int gettemperature()
  e2:	08 95       	ret

000000e4 <main>:
	 
	bool checkEnable(){return (stateWork_ == enable_fan ? true : false);}                     // Проверяет, есть ли сигнал для включении вентилятора
		
	void disable(numberFan FAN)                                                               // Выключает вентилятор
	{                                                               //
		this->stateWork_ = disable_fan;                             // Обновить статус на "выключено"
  e4:	00 e7       	ldi	r16, 0x70	; 112
  e6:	10 e0       	ldi	r17, 0x00	; 0
  e8:	dd 24       	eor	r13, r13
  ea:	d3 94       	inc	r13
  ec:	0f 2e       	mov	r0, r31
  ee:	fb e6       	ldi	r31, 0x6B	; 107
  f0:	ef 2e       	mov	r14, r31
  f2:	f0 e0       	ldi	r31, 0x00	; 0
  f4:	ff 2e       	mov	r15, r31
  f6:	f0 2d       	mov	r31, r0
	
	void reset(void){flagTimer_ = true;}                                          // Сброс таймера в 0
	
	void start(unsigned int endTime)                                              // Метод начала отсчёта таймера
	{                                                                             //
		if(flagTimer_)                                                            // Если флаг таймера поднят, запоминаем время начала отсчёта:
  f8:	c0 e6       	ldi	r28, 0x60	; 96
  fa:	d0 e0       	ldi	r29, 0x00	; 0
	void blink(numberLed led)                                                                  // Установть мерцание ветодиода
	{                                                                //
		/* Статус "мерцание" аппаратно  реализуется в прерывании     //
		таймера-счётчика 0                                           //
		*/                                                           //
		this->state_ = blink_led;                                    // Обновить статус на "мигание"
  fc:	68 94       	set
  fe:	cc 24       	eor	r12, r12
 100:	c1 f8       	bld	r12, 1
						{
							if (fan2.getStatFeedback() == Fan::normal)  // Венилятор2 : норма
							{
								led_N2.blink(Led::LED_N2);              // LED_N2 мигает
								led_A2.disable(Led::LED_A2);            // LED_A2 отключён
								stateWork = STATE_WAIT_HOLD;            // Переход в состояние "Ожидание нижнего порога температур"
 102:	68 94       	set
 104:	aa 24       	eor	r10, r10
 106:	a2 f8       	bld	r10, 2
				{
					led_N2.disable(Led::LED_N2);                   // LED_N2 отключён
					led_A2.enable(Led::LED_A2);                    // LED_А2 горит
				}
				timer.reset();                                     // Сбрасываем таймер
				stateWork = STATE_WAIT_HEAT;                       // Переходим в режим "Ожидание верхнего порога температуры"
 108:	0f 2e       	mov	r0, r31
 10a:	f3 e0       	ldi	r31, 0x03	; 3
 10c:	bf 2e       	mov	r11, r31
 10e:	f0 2d       	mov	r31, r0
			led_A1.enable(Led::LED_A1);
			led_A2.enable(Led::LED_A2);
			standType = PINA & (1 << PA6) ? STAND52_54 : STAND51;                // Если в PA6(JMP1) еденица - стойка 52/54, иначе стойка 51
			fan1.setType(PINA & (1 << PA7) ?  Fan::FAN_AR00  : Fan::FAN_AF00);   // Если в PA7(JMP2) еденица - вентилятор AR00, иначе AF00
			fan2.setType(fan2.getType());                                        // Типы вентиляторов одинаковы - копируем тип в вентилятор 2
			if (fan1.getType() == Fan::FAN_AF00) GICR = (1 << INT1)|(1 << INT0); // Разрешение прерываний INT1 и INT0 для получения сигналов SFAN1 и SFAN2 в случае вентилятора типа "частота"
 110:	0f 2e       	mov	r0, r31
 112:	f0 ec       	ldi	r31, 0xC0	; 192
 114:	9f 2e       	mov	r9, r31
 116:	f0 2d       	mov	r31, r0
int main(void)
{
	while (1)
	{
		wdt_reset();
		switch(stateWork)                                                       // Выбор текущего статуса работы
 118:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <stateWork>

int main(void)
{
	while (1)
	{
		wdt_reset();
 11c:	a8 95       	wdr
		switch(stateWork)                                                       // Выбор текущего статуса работы
 11e:	82 30       	cpi	r24, 0x02	; 2
 120:	09 f4       	brne	.+2      	; 0x124 <main+0x40>
 122:	4d c0       	rjmp	.+154    	; 0x1be <main+0xda>
 124:	28 f4       	brcc	.+10     	; 0x130 <main+0x4c>
 126:	88 23       	and	r24, r24
 128:	51 f0       	breq	.+20     	; 0x13e <main+0x5a>
 12a:	81 30       	cpi	r24, 0x01	; 1
 12c:	b9 f1       	breq	.+110    	; 0x19c <main+0xb8>
 12e:	f6 cf       	rjmp	.-20     	; 0x11c <main+0x38>
 130:	83 30       	cpi	r24, 0x03	; 3
 132:	09 f4       	brne	.+2      	; 0x136 <main+0x52>
 134:	54 c1       	rjmp	.+680    	; 0x3de <__stack+0x17f>
 136:	84 30       	cpi	r24, 0x04	; 4
 138:	09 f4       	brne	.+2      	; 0x13c <main+0x58>
 13a:	4c c2       	rjmp	.+1176   	; 0x5d4 <__LOCK_REGION_LENGTH__+0x1d4>
 13c:	ef cf       	rjmp	.-34     	; 0x11c <main+0x38>
		{
			case STATE_INITIALIZE:/*--------------------------- Статус "ИНИЦИАЛИЗАЦИЯ" --------------------------------------------------*/
			cli();
 13e:	f8 94       	cli
			port_initialize();                                                   // Инициализируем порты ввода-вывода
 140:	90 df       	rcall	.-224    	; 0x62 <_Z15port_initializev>
			ADC_initialize();                                                    // Инициализируем АЦП на еденичное преобразование
 142:	b0 df       	rcall	.-160    	; 0xa4 <_Z14ADC_initializev>
			externalInterruption_initialize();                                   // Инициализируем внешние прерывания для чтения статуса вентилятора AF00
 144:	b4 df       	rcall	.-152    	; 0xae <_Z31externalInterruption_initializev>
			counter0_initialize();                                               // Инициализируем и запускаем таймер-счётчик 0
 146:	c0 df       	rcall	.-128    	; 0xc8 <_Z19counter0_initializev>
			WDT_enable();                                                        // Запускаем сторожевой таймер по алгоритму "уровня безопасности 2"
 148:	b5 df       	rcall	.-150    	; 0xb4 <_Z10WDT_enablev>
			sei();
 14a:	78 94       	sei
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 14c:	10 92 6a 00 	sts	0x006A, r1	; 0x80006a <led_N1>
		switch (led)                                                 // 
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
 150:	96 9a       	sbi	0x12, 6	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 152:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <led_N2>
		switch (led)                                                 // 
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
 156:	97 9a       	sbi	0x12, 7	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 158:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
 15c:	94 9a       	sbi	0x12, 4	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 15e:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
			break;                                                   //
			case LED_A2: PORTD |=  (1 << PD5);                       // LED_A2 : записать 1 в PD5
 162:	95 9a       	sbi	0x12, 5	; 18
			sei();
			led_N1.enable(Led::LED_N1);                                          // Включаем все всетодиоды
			led_N2.enable(Led::LED_N2);
			led_A1.enable(Led::LED_A1);
			led_A2.enable(Led::LED_A2);
			standType = PINA & (1 << PA6) ? STAND52_54 : STAND51;                // Если в PA6(JMP1) еденица - стойка 52/54, иначе стойка 51
 164:	89 b3       	in	r24, 0x19	; 25
 166:	86 fb       	bst	r24, 6
 168:	88 27       	eor	r24, r24
 16a:	80 f9       	bld	r24, 0
 16c:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <standType>
			fan1.setType(PINA & (1 << PA7) ?  Fan::FAN_AR00  : Fan::FAN_AF00);   // Если в PA7(JMP2) еденица - вентилятор AR00, иначе AF00
 170:	89 b3       	in	r24, 0x19	; 25
 172:	80 95       	com	r24
 174:	88 1f       	adc	r24, r24
 176:	88 27       	eor	r24, r24
 178:	88 1f       	adc	r24, r24
	typedef enum {enable_fan,disable_fan,}stateWorkFan;            // Возможные состояния вентиляторов 
	typedef enum {fail,normal,}stateFeedbackFan;                   // Статус вентиляторов 
	typedef enum{FAN_AR00,FAN_AF00,}typeFan;                       // Типы вентиляторов 
	typedef enum {FAN1,FAN2} numberFan;                            // Названия вентиляторов

	void setType(typeFan type) {this->type_ = type;}                                         // Устанавливает тип вентилятора
 17a:	f8 01       	movw	r30, r16
 17c:	80 83       	st	Z, r24
			led_A1.enable(Led::LED_A1);
			led_A2.enable(Led::LED_A2);
			standType = PINA & (1 << PA6) ? STAND52_54 : STAND51;                // Если в PA6(JMP1) еденица - стойка 52/54, иначе стойка 51
			fan1.setType(PINA & (1 << PA7) ?  Fan::FAN_AR00  : Fan::FAN_AF00);   // Если в PA7(JMP2) еденица - вентилятор AR00, иначе AF00
			fan2.setType(fan2.getType());                                        // Типы вентиляторов одинаковы - копируем тип в вентилятор 2
			if (fan1.getType() == Fan::FAN_AF00) GICR = (1 << INT1)|(1 << INT0); // Разрешение прерываний INT1 и INT0 для получения сигналов SFAN1 и SFAN2 в случае вентилятора типа "частота"
 17e:	81 30       	cpi	r24, 0x01	; 1
 180:	09 f4       	brne	.+2      	; 0x184 <main+0xa0>
 182:	9b be       	out	0x3b, r9	; 59
Led led_A1;    // Создаём объект "светодиод авария 1"
Led led_A2;    // Создаём объект "светодиод авария 2"
Time timer;    // Создаём объект "таймер            "

int main(void)
{
 184:	80 e3       	ldi	r24, 0x30	; 48
 186:	93 e6       	ldi	r25, 0x63	; 99
 188:	a3 e0       	ldi	r26, 0x03	; 3
 18a:	b0 e0       	ldi	r27, 0x00	; 0
			led_A2.enable(Led::LED_A2);
			standType = PINA & (1 << PA6) ? STAND52_54 : STAND51;                // Если в PA6(JMP1) еденица - стойка 52/54, иначе стойка 51
			fan1.setType(PINA & (1 << PA7) ?  Fan::FAN_AR00  : Fan::FAN_AF00);   // Если в PA7(JMP2) еденица - вентилятор AR00, иначе AF00
			fan2.setType(fan2.getType());                                        // Типы вентиляторов одинаковы - копируем тип в вентилятор 2
			if (fan1.getType() == Fan::FAN_AF00) GICR = (1 << INT1)|(1 << INT0); // Разрешение прерываний INT1 и INT0 для получения сигналов SFAN1 и SFAN2 в случае вентилятора типа "частота"
			delay_ms(1000);
 18c:	00 00       	nop
 18e:	01 97       	sbiw	r24, 0x01	; 1
 190:	a1 09       	sbc	r26, r1
 192:	b1 09       	sbc	r27, r1
 194:	d9 f7       	brne	.-10     	; 0x18c <main+0xa8>
			stateWork = STATE_WAIT_SOLUTION_TURN;                                // Переход в состояние ожидания разрешения включения вентиляторов
 196:	d0 92 76 00 	sts	0x0076, r13	; 0x800076 <stateWork>
			break; // конец case STATE_INITIALIZE:
 19a:	be cf       	rjmp	.-132    	; 0x118 <main+0x34>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 19c:	d0 92 6a 00 	sts	0x006A, r13	; 0x80006a <led_N1>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
 1a0:	96 98       	cbi	0x12, 6	; 18
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 1a2:	d0 92 69 00 	sts	0x0069, r13	; 0x800069 <led_N2>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
 1a6:	97 98       	cbi	0x12, 7	; 18
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 1a8:	d0 92 68 00 	sts	0x0068, r13	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
 1ac:	94 98       	cbi	0x12, 4	; 18
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 1ae:	d0 92 67 00 	sts	0x0067, r13	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
			break;                                                   //
			case LED_A2: PORTD &=  ~(1 << PD5);                      // LED_A2 : записать 0 в PD5
 1b2:	95 98       	cbi	0x12, 5	; 18
			case STATE_WAIT_SOLUTION_TURN:/*------------------- Статус "ОЖИДАНИЕ РАЗРЕШЕНИЯ ВКЛЮЧЕНИЯ ВЕНТИЛЯТОРОВ" ------------------------*/
			led_N1.disable(Led::LED_N1);                                          // Выключаем все всетодиоды
			led_N2.disable(Led::LED_N2);
			led_A1.disable(Led::LED_A1);
			led_A2.disable(Led::LED_A2);
			if(PINC & (1 << PC2)) stateWork = STATE_DIAGNOSTICS;                  // Если на PC2 (ON) еденица - переход в режим самодиагностики
 1b4:	9a 9b       	sbis	0x13, 2	; 19
 1b6:	b0 cf       	rjmp	.-160    	; 0x118 <main+0x34>
 1b8:	c0 92 76 00 	sts	0x0076, r12	; 0x800076 <stateWork>
 1bc:	ad cf       	rjmp	.-166    	; 0x118 <main+0x34>
			break;  // конец case STATE_WAIT_SOLUTION_TURN:
			
			case STATE_DIAGNOSTICS:/*--------------------------- Статус "САМОДИАГНОСТИКА" ---------------------------------------------------*/
			if (standType == STAND51) //-------------------        Для стойки 51
 1be:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <standType>
 1c2:	81 11       	cpse	r24, r1
 1c4:	7d c0       	rjmp	.+250    	; 0x2c0 <__stack+0x61>
	
	void reset(void){flagTimer_ = true;}                                          // Сброс таймера в 0
	
	void start(unsigned int endTime)                                              // Метод начала отсчёта таймера
	{                                                                             //
		if(flagTimer_)                                                            // Если флаг таймера поднят, запоминаем время начала отсчёта:
 1c6:	8c 81       	ldd	r24, Y+4	; 0x04
 1c8:	88 23       	and	r24, r24
 1ca:	31 f0       	breq	.+12     	; 0x1d8 <main+0xf4>
		{                                                                         //
			startTime_ = globalTime_;                                             // Запоминаем текущее время глобвльных часов
 1cc:	88 81       	ld	r24, Y
 1ce:	99 81       	ldd	r25, Y+1	; 0x01
 1d0:	9b 83       	std	Y+3, r25	; 0x03
 1d2:	8a 83       	std	Y+2, r24	; 0x02
			flagTimer_ = false;                                                   // Опускаем флаг таймера, начинаем считать:
 1d4:	1c 82       	std	Y+4, r1	; 0x04
 1d6:	34 c0       	rjmp	.+104    	; 0x240 <main+0x15c>
		}                                                                         //
		else                                                                      // Если флаг таймера опущен
		{                                                                         //
			if (startTime_ + endTime > MAX_TIME )                                 // Суммарное время превышает максимальное число таймера
 1d8:	8a 81       	ldd	r24, Y+2	; 0x02
 1da:	9b 81       	ldd	r25, Y+3	; 0x03
 1dc:	9c 01       	movw	r18, r24
 1de:	28 57       	subi	r18, 0x78	; 120
 1e0:	3c 4e       	sbci	r19, 0xEC	; 236
 1e2:	2d 3f       	cpi	r18, 0xFD	; 253
 1e4:	f9 ee       	ldi	r31, 0xE9	; 233
 1e6:	3f 07       	cpc	r19, r31
 1e8:	00 f1       	brcs	.+64     	; 0x22a <main+0x146>
			{                                                                     //
				timeTimer_ = globalTime_ <= MAX_TIME ? globalTime_ - startTime_: MAX_TIME - startTime_ + globalTime_; // Запоминаем текущее время таймере
 1ea:	48 81       	ld	r20, Y
 1ec:	59 81       	ldd	r21, Y+1	; 0x01
 1ee:	4d 3f       	cpi	r20, 0xFD	; 253
 1f0:	29 ee       	ldi	r18, 0xE9	; 233
 1f2:	52 07       	cpc	r21, r18
 1f4:	20 f4       	brcc	.+8      	; 0x1fe <main+0x11a>
 1f6:	9a 01       	movw	r18, r20
 1f8:	28 1b       	sub	r18, r24
 1fa:	39 0b       	sbc	r19, r25
 1fc:	05 c0       	rjmp	.+10     	; 0x208 <main+0x124>
 1fe:	9a 01       	movw	r18, r20
 200:	24 50       	subi	r18, 0x04	; 4
 202:	36 41       	sbci	r19, 0x16	; 22
 204:	28 1b       	sub	r18, r24
 206:	39 0b       	sbc	r19, r25
 208:	3e 83       	std	Y+6, r19	; 0x06
 20a:	2d 83       	std	Y+5, r18	; 0x05
				if (globalTime_ == startTime_ - (MAX_TIME -  endTime) )  flagTimer_ = true;                           // Делаем поправку, переводя время окончания на начало часов,
 20c:	60 e0       	ldi	r22, 0x00	; 0
 20e:	70 e0       	ldi	r23, 0x00	; 0
 210:	a0 e0       	ldi	r26, 0x00	; 0
 212:	b0 e0       	ldi	r27, 0x00	; 0
 214:	84 57       	subi	r24, 0x74	; 116
 216:	96 4d       	sbci	r25, 0xD6	; 214
 218:	a1 09       	sbc	r26, r1
 21a:	b1 09       	sbc	r27, r1
 21c:	48 17       	cp	r20, r24
 21e:	59 07       	cpc	r21, r25
 220:	6a 07       	cpc	r22, r26
 222:	7b 07       	cpc	r23, r27
 224:	69 f4       	brne	.+26     	; 0x240 <main+0x15c>
 226:	dc 82       	std	Y+4, r13	; 0x04
 228:	0b c0       	rjmp	.+22     	; 0x240 <main+0x15c>
			}                                                                     // Когда отсчёт окончен, поднимаем флажок для запоминания следующего времени
			else                                                                  // Если время окончания отсчёта не преышает максимум часов
			{                                                                     //
				timeTimer_ = globalTime_ - startTime_;                            // Запоминаем текущее время таймера
 22a:	48 81       	ld	r20, Y
 22c:	59 81       	ldd	r21, Y+1	; 0x01
 22e:	ba 01       	movw	r22, r20
 230:	68 1b       	sub	r22, r24
 232:	79 0b       	sbc	r23, r25
 234:	7e 83       	std	Y+6, r23	; 0x06
 236:	6d 83       	std	Y+5, r22	; 0x05
				if (globalTime_ == startTime_ + endTime) flagTimer_ = true;       // Если время окончания отсчёта не превышает максимум часов и отсчитали установленное время,поднимаем флажок
 238:	24 17       	cp	r18, r20
 23a:	35 07       	cpc	r19, r21
 23c:	09 f4       	brne	.+2      	; 0x240 <main+0x15c>
 23e:	dc 82       	std	Y+4, r13	; 0x04
	
	unsigned int getTimeToFail(){return timeToFail_;}                                         // Получает время ло принятия решения о неработоспособности вентиляторов
	
	void enable(numberFan FAN)                                                                // Включает вентилятор
	{                                                              //
		this->stateWork_ = enable_fan;                             // Обновить статус на "включено"
 240:	f8 01       	movw	r30, r16
 242:	12 82       	std	Z+2, r1	; 0x02
		if (FAN == FAN1) PORTC |=  (1 << PC3);                     // Если хотим включить вентилятор1, записываем 1 в PC3
 244:	ab 9a       	sbi	0x15, 3	; 21
	
	unsigned int getTimeToFail(){return timeToFail_;}                                         // Получает время ло принятия решения о неработоспособности вентиляторов
	
	void enable(numberFan FAN)                                                                // Включает вентилятор
	{                                                              //
		this->stateWork_ = enable_fan;                             // Обновить статус на "включено"
 246:	f7 01       	movw	r30, r14
 248:	12 82       	std	Z+2, r1	; 0x02
		if (FAN == FAN1) PORTC |=  (1 << PC3);                     // Если хотим включить вентилятор1, записываем 1 в PC3
		else PORTC |=  (1 << PC4);                                 // Если хотим включить вентилятор2, записываем 1 в PC4
 24a:	ac 9a       	sbi	0x15, 4	; 21
	void blink(numberLed led)                                                                  // Установть мерцание ветодиода
	{                                                                //
		/* Статус "мерцание" аппаратно  реализуется в прерывании     //
		таймера-счётчика 0                                           //
		*/                                                           //
		this->state_ = blink_led;                                    // Обновить статус на "мигание"
 24c:	c0 92 6a 00 	sts	0x006A, r12	; 0x80006a <led_N1>
 250:	c0 92 69 00 	sts	0x0069, r12	; 0x800069 <led_N2>
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 254:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
 258:	94 9a       	sbi	0x12, 4	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 25a:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
			break;                                                   //
			case LED_A2: PORTD |=  (1 << PD5);                       // LED_A2 : записать 1 в PD5
 25e:	95 9a       	sbi	0x12, 5	; 18
				fan2.enable(Fan::FAN2);
				led_N1.blink(Led::LED_N1);                     // LED_N1 моргает
				led_N2.blink(Led::LED_N2);                     // LED_N2 моргает
				led_A1.enable(Led::LED_A1);                    // LED_А1 горит
				led_A2.enable(Led::LED_A2);                    // LED_А2 горит
				if (timer.endTimer())                          // Отсчёт 5ти секунд окончен - проверяем состояния
 260:	8c 81       	ldd	r24, Y+4	; 0x04
 262:	88 23       	and	r24, r24
 264:	09 f4       	brne	.+2      	; 0x268 <__stack+0x9>
 266:	58 cf       	rjmp	.-336    	; 0x118 <main+0x34>
	 
	bool checkEnable(){return (stateWork_ == enable_fan ? true : false);}                     // Проверяет, есть ли сигнал для включении вентилятора
		
	void disable(numberFan FAN)                                                               // Выключает вентилятор
	{                                                               //
		this->stateWork_ = disable_fan;                             // Обновить статус на "выключено"
 268:	f8 01       	movw	r30, r16
 26a:	d2 82       	std	Z+2, r13	; 0x02
		if (FAN == FAN1) PORTC &= ~(1 << PC3);                      // Если хотим выключить вентилятор1, записываем 0 в PC3
 26c:	ab 98       	cbi	0x15, 3	; 21
	 
	bool checkEnable(){return (stateWork_ == enable_fan ? true : false);}                     // Проверяет, есть ли сигнал для включении вентилятора
		
	void disable(numberFan FAN)                                                               // Выключает вентилятор
	{                                                               //
		this->stateWork_ = disable_fan;                             // Обновить статус на "выключено"
 26e:	f7 01       	movw	r30, r14
 270:	d2 82       	std	Z+2, r13	; 0x02
		if (FAN == FAN1) PORTC &= ~(1 << PC3);                      // Если хотим выключить вентилятор1, записываем 0 в PC3
		else PORTC &= ~(1 << PC4);                                  // Если хотим выключить вентилятор2, записываем 0 в PC4
 272:	ac 98       	cbi	0x15, 4	; 21
				led_A2.enable(Led::LED_A2);                    // LED_А2 горит
				if (timer.endTimer())                          // Отсчёт 5ти секунд окончен - проверяем состояния
				{
					fan1.disable(Fan::FAN1);                   // Отключили все вентиляторы
					fan2.disable(Fan::FAN2);
					if (fan1.getStatFeedback() == Fan::normal) // Смотрим состояние : вентилятор1 в норме
 274:	f8 01       	movw	r30, r16
 276:	81 81       	ldd	r24, Z+1	; 0x01
 278:	81 30       	cpi	r24, 0x01	; 1
 27a:	39 f4       	brne	.+14     	; 0x28a <__stack+0x2b>
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 27c:	10 92 6a 00 	sts	0x006A, r1	; 0x80006a <led_N1>
		switch (led)                                                 // 
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
 280:	96 9a       	sbi	0x12, 6	; 18
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 282:	d0 92 68 00 	sts	0x0068, r13	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
 286:	94 98       	cbi	0x12, 4	; 18
 288:	06 c0       	rjmp	.+12     	; 0x296 <__stack+0x37>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 28a:	d0 92 6a 00 	sts	0x006A, r13	; 0x80006a <led_N1>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
 28e:	96 98       	cbi	0x12, 6	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 290:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
 294:	94 9a       	sbi	0x12, 4	; 18
					else                                       // Вентилятор1 : авария
					{
						led_N1.disable(Led::LED_N1);           // LED_N1 откоючён
						led_A1.enable(Led::LED_A1);            // LED_А1 горит
					}
					if (fan2.getStatFeedback() == Fan::normal) // Вентилятор2 : норма
 296:	f7 01       	movw	r30, r14
 298:	81 81       	ldd	r24, Z+1	; 0x01
 29a:	81 30       	cpi	r24, 0x01	; 1
 29c:	39 f4       	brne	.+14     	; 0x2ac <__stack+0x4d>
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 29e:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <led_N2>
		switch (led)                                                 // 
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
 2a2:	97 9a       	sbi	0x12, 7	; 18
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 2a4:	d0 92 67 00 	sts	0x0067, r13	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
			break;                                                   //
			case LED_A2: PORTD &=  ~(1 << PD5);                      // LED_A2 : записать 0 в PD5
 2a8:	95 98       	cbi	0x12, 5	; 18
 2aa:	06 c0       	rjmp	.+12     	; 0x2b8 <__stack+0x59>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 2ac:	d0 92 69 00 	sts	0x0069, r13	; 0x800069 <led_N2>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
 2b0:	97 98       	cbi	0x12, 7	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 2b2:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
			break;                                                   //
			case LED_A2: PORTD |=  (1 << PD5);                       // LED_A2 : записать 1 в PD5
 2b6:	95 9a       	sbi	0x12, 5	; 18
	public:
	void setGlobalTime(unsigned int globalTime) {this->globalTime_ = globalTime;} // Установка глобальных часов (в прерывании таймера-счётчика0)
	
	unsigned int getGlobalTime(void)            {return globalTime_;}             // Метод получения текущего времени для его обновления в прерывании таймера-счётчика0
	
	void reset(void){flagTimer_ = true;}                                          // Сброс таймера в 0
 2b8:	dc 82       	std	Y+4, r13	; 0x04
					{
						led_N2.disable(Led::LED_N2);           // LED_N2 отколючён
						led_A2.enable(Led::LED_A2);            // LED_А2 горит
					}
					timer.reset();                             // 5 секунд теста окончены - сбросить таймер
					stateWork = STATE_WAIT_HEAT;               // Переходим в состояние ожидания верхнего порога температуры
 2ba:	b0 92 76 00 	sts	0x0076, r11	; 0x800076 <stateWork>
 2be:	2c cf       	rjmp	.-424    	; 0x118 <main+0x34>
	
	void reset(void){flagTimer_ = true;}                                          // Сброс таймера в 0
	
	void start(unsigned int endTime)                                              // Метод начала отсчёта таймера
	{                                                                             //
		if(flagTimer_)                                                            // Если флаг таймера поднят, запоминаем время начала отсчёта:
 2c0:	8c 81       	ldd	r24, Y+4	; 0x04
 2c2:	88 23       	and	r24, r24
 2c4:	31 f0       	breq	.+12     	; 0x2d2 <__stack+0x73>
		{                                                                         //
			startTime_ = globalTime_;                                             // Запоминаем текущее время глобвльных часов
 2c6:	88 81       	ld	r24, Y
 2c8:	99 81       	ldd	r25, Y+1	; 0x01
 2ca:	9b 83       	std	Y+3, r25	; 0x03
 2cc:	8a 83       	std	Y+2, r24	; 0x02
			flagTimer_ = false;                                                   // Опускаем флаг таймера, начинаем считать:
 2ce:	1c 82       	std	Y+4, r1	; 0x04
 2d0:	34 c0       	rjmp	.+104    	; 0x33a <__stack+0xdb>
		}                                                                         //
		else                                                                      // Если флаг таймера опущен
		{                                                                         //
			if (startTime_ + endTime > MAX_TIME )                                 // Суммарное время превышает максимальное число таймера
 2d2:	8a 81       	ldd	r24, Y+2	; 0x02
 2d4:	9b 81       	ldd	r25, Y+3	; 0x03
 2d6:	9c 01       	movw	r18, r24
 2d8:	20 5f       	subi	r18, 0xF0	; 240
 2da:	38 4d       	sbci	r19, 0xD8	; 216
 2dc:	2d 3f       	cpi	r18, 0xFD	; 253
 2de:	f9 ee       	ldi	r31, 0xE9	; 233
 2e0:	3f 07       	cpc	r19, r31
 2e2:	00 f1       	brcs	.+64     	; 0x324 <__stack+0xc5>
			{                                                                     //
				timeTimer_ = globalTime_ <= MAX_TIME ? globalTime_ - startTime_: MAX_TIME - startTime_ + globalTime_; // Запоминаем текущее время таймере
 2e4:	48 81       	ld	r20, Y
 2e6:	59 81       	ldd	r21, Y+1	; 0x01
 2e8:	4d 3f       	cpi	r20, 0xFD	; 253
 2ea:	29 ee       	ldi	r18, 0xE9	; 233
 2ec:	52 07       	cpc	r21, r18
 2ee:	20 f4       	brcc	.+8      	; 0x2f8 <__stack+0x99>
 2f0:	9a 01       	movw	r18, r20
 2f2:	28 1b       	sub	r18, r24
 2f4:	39 0b       	sbc	r19, r25
 2f6:	05 c0       	rjmp	.+10     	; 0x302 <__stack+0xa3>
 2f8:	9a 01       	movw	r18, r20
 2fa:	24 50       	subi	r18, 0x04	; 4
 2fc:	36 41       	sbci	r19, 0x16	; 22
 2fe:	28 1b       	sub	r18, r24
 300:	39 0b       	sbc	r19, r25
 302:	3e 83       	std	Y+6, r19	; 0x06
 304:	2d 83       	std	Y+5, r18	; 0x05
				if (globalTime_ == startTime_ - (MAX_TIME -  endTime) )  flagTimer_ = true;                           // Делаем поправку, переводя время окончания на начало часов,
 306:	60 e0       	ldi	r22, 0x00	; 0
 308:	70 e0       	ldi	r23, 0x00	; 0
 30a:	a0 e0       	ldi	r26, 0x00	; 0
 30c:	b0 e0       	ldi	r27, 0x00	; 0
 30e:	8c 5e       	subi	r24, 0xEC	; 236
 310:	92 4c       	sbci	r25, 0xC2	; 194
 312:	a1 09       	sbc	r26, r1
 314:	b1 09       	sbc	r27, r1
 316:	48 17       	cp	r20, r24
 318:	59 07       	cpc	r21, r25
 31a:	6a 07       	cpc	r22, r26
 31c:	7b 07       	cpc	r23, r27
 31e:	69 f4       	brne	.+26     	; 0x33a <__stack+0xdb>
 320:	dc 82       	std	Y+4, r13	; 0x04
 322:	0b c0       	rjmp	.+22     	; 0x33a <__stack+0xdb>
			}                                                                     // Когда отсчёт окончен, поднимаем флажок для запоминания следующего времени
			else                                                                  // Если время окончания отсчёта не преышает максимум часов
			{                                                                     //
				timeTimer_ = globalTime_ - startTime_;                            // Запоминаем текущее время таймера
 324:	48 81       	ld	r20, Y
 326:	59 81       	ldd	r21, Y+1	; 0x01
 328:	ba 01       	movw	r22, r20
 32a:	68 1b       	sub	r22, r24
 32c:	79 0b       	sbc	r23, r25
 32e:	7e 83       	std	Y+6, r23	; 0x06
 330:	6d 83       	std	Y+5, r22	; 0x05
				if (globalTime_ == startTime_ + endTime) flagTimer_ = true;       // Если время окончания отсчёта не превышает максимум часов и отсчитали установленное время,поднимаем флажок
 332:	24 17       	cp	r18, r20
 334:	35 07       	cpc	r19, r21
 336:	09 f4       	brne	.+2      	; 0x33a <__stack+0xdb>
 338:	dc 82       	std	Y+4, r13	; 0x04
			}                                                                     //
		}                                                                         //
	}// конец void start(unsigned int endTime)    
	
	unsigned int getTimerTime(void) {return timeTimer_;}                          // Получить текущее время таймера
 33a:	8d 81       	ldd	r24, Y+5	; 0x05
 33c:	9e 81       	ldd	r25, Y+6	; 0x06
				}
			} // конец STAND51
			else//---------------------------------------------Стойка 52/54
			{
				timer.start(10000);                                // Включить таймер на 10 секунд (5 на 1 вентилятор, 5 на другой)
				if (timer.getTimerTime() < 5000)                   // Пока идет тест вентилятора 1
 33e:	88 38       	cpi	r24, 0x88	; 136
 340:	73 e1       	ldi	r23, 0x13	; 19
 342:	97 07       	cpc	r25, r23
 344:	90 f4       	brcc	.+36     	; 0x36a <__stack+0x10b>
	
	unsigned int getTimeToFail(){return timeToFail_;}                                         // Получает время ло принятия решения о неработоспособности вентиляторов
	
	void enable(numberFan FAN)                                                                // Включает вентилятор
	{                                                              //
		this->stateWork_ = enable_fan;                             // Обновить статус на "включено"
 346:	f8 01       	movw	r30, r16
 348:	12 82       	std	Z+2, r1	; 0x02
		if (FAN == FAN1) PORTC |=  (1 << PC3);                     // Если хотим включить вентилятор1, записываем 1 в PC3
 34a:	ab 9a       	sbi	0x15, 3	; 21
	 
	bool checkEnable(){return (stateWork_ == enable_fan ? true : false);}                     // Проверяет, есть ли сигнал для включении вентилятора
		
	void disable(numberFan FAN)                                                               // Выключает вентилятор
	{                                                               //
		this->stateWork_ = disable_fan;                             // Обновить статус на "выключено"
 34c:	f7 01       	movw	r30, r14
 34e:	d2 82       	std	Z+2, r13	; 0x02
		if (FAN == FAN1) PORTC &= ~(1 << PC3);                      // Если хотим выключить вентилятор1, записываем 0 в PC3
		else PORTC &= ~(1 << PC4);                                  // Если хотим выключить вентилятор2, записываем 0 в PC4
 350:	ac 98       	cbi	0x15, 4	; 21
	void blink(numberLed led)                                                                  // Установть мерцание ветодиода
	{                                                                //
		/* Статус "мерцание" аппаратно  реализуется в прерывании     //
		таймера-счётчика 0                                           //
		*/                                                           //
		this->state_ = blink_led;                                    // Обновить статус на "мигание"
 352:	c0 92 6a 00 	sts	0x006A, r12	; 0x80006a <led_N1>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 356:	d0 92 69 00 	sts	0x0069, r13	; 0x800069 <led_N2>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
 35a:	97 98       	cbi	0x12, 7	; 18
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 35c:	d0 92 68 00 	sts	0x0068, r13	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
 360:	94 98       	cbi	0x12, 4	; 18
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 362:	d0 92 67 00 	sts	0x0067, r13	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
			break;                                                   //
			case LED_A2: PORTD &=  ~(1 << PD5);                      // LED_A2 : записать 0 в PD5
 366:	95 98       	cbi	0x12, 5	; 18
 368:	d7 ce       	rjmp	.-594    	; 0x118 <main+0x34>
					led_N1.blink(Led::LED_N1);                     // LED_N1 мигает
					led_N2.disable(Led::LED_N2);                   // LED_N2 отколючён
					led_A1.disable(Led::LED_A1);                   // LED_А1 отключён
					led_A2.disable(Led::LED_A2);                   // LED_А2 отключён
				}
				else if (timer.getTimerTime() == 5000)             // По истечению 5ти секунд смотрим состояние вентилятора 1
 36a:	88 38       	cpi	r24, 0x88	; 136
 36c:	93 41       	sbci	r25, 0x13	; 19
 36e:	91 f4       	brne	.+36     	; 0x394 <__stack+0x135>
				{
					if (fan1.getStatFeedback() == Fan::normal)     // Вентилятор1 : норма
 370:	f8 01       	movw	r30, r16
 372:	81 81       	ldd	r24, Z+1	; 0x01
 374:	81 30       	cpi	r24, 0x01	; 1
 376:	39 f4       	brne	.+14     	; 0x386 <__stack+0x127>
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 378:	10 92 6a 00 	sts	0x006A, r1	; 0x80006a <led_N1>
		switch (led)                                                 // 
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
 37c:	96 9a       	sbi	0x12, 6	; 18
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 37e:	d0 92 68 00 	sts	0x0068, r13	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
 382:	94 98       	cbi	0x12, 4	; 18
 384:	c9 ce       	rjmp	.-622    	; 0x118 <main+0x34>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 386:	d0 92 6a 00 	sts	0x006A, r13	; 0x80006a <led_N1>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
 38a:	96 98       	cbi	0x12, 6	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 38c:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
 390:	94 9a       	sbi	0x12, 4	; 18
 392:	c2 ce       	rjmp	.-636    	; 0x118 <main+0x34>
	 
	bool checkEnable(){return (stateWork_ == enable_fan ? true : false);}                     // Проверяет, есть ли сигнал для включении вентилятора
		
	void disable(numberFan FAN)                                                               // Выключает вентилятор
	{                                                               //
		this->stateWork_ = disable_fan;                             // Обновить статус на "выключено"
 394:	f8 01       	movw	r30, r16
 396:	d2 82       	std	Z+2, r13	; 0x02
		if (FAN == FAN1) PORTC &= ~(1 << PC3);                      // Если хотим выключить вентилятор1, записываем 0 в PC3
 398:	ab 98       	cbi	0x15, 3	; 21
	
	unsigned int getTimeToFail(){return timeToFail_;}                                         // Получает время ло принятия решения о неработоспособности вентиляторов
	
	void enable(numberFan FAN)                                                                // Включает вентилятор
	{                                                              //
		this->stateWork_ = enable_fan;                             // Обновить статус на "включено"
 39a:	f7 01       	movw	r30, r14
 39c:	12 82       	std	Z+2, r1	; 0x02
		if (FAN == FAN1) PORTC |=  (1 << PC3);                     // Если хотим включить вентилятор1, записываем 1 в PC3
		else PORTC |=  (1 << PC4);                                 // Если хотим включить вентилятор2, записываем 1 в PC4
 39e:	ac 9a       	sbi	0x15, 4	; 21
	void blink(numberLed led)                                                                  // Установть мерцание ветодиода
	{                                                                //
		/* Статус "мерцание" аппаратно  реализуется в прерывании     //
		таймера-счётчика 0                                           //
		*/                                                           //
		this->state_ = blink_led;                                    // Обновить статус на "мигание"
 3a0:	c0 92 69 00 	sts	0x0069, r12	; 0x800069 <led_N2>
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 3a4:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
			break;                                                   //
			case LED_A2: PORTD |=  (1 << PD5);                       // LED_A2 : записать 1 в PD5
 3a8:	95 9a       	sbi	0x12, 5	; 18
				{
					fan1.disable(Fan::FAN1);                       // Отключить вентилятор1
					fan2.enable(Fan::FAN2);                        // Включить вентилятор2
					led_N2.blink(Led::LED_N2);                     // LED_N2 мигает
					led_A2.enable(Led::LED_A2);                    // LED_А2 горит
					if (timer.endTimer())                          // Суммарные 10 секунд теста истекло : смотрим результат для вентилятора 2
 3aa:	8c 81       	ldd	r24, Y+4	; 0x04
 3ac:	88 23       	and	r24, r24
 3ae:	09 f4       	brne	.+2      	; 0x3b2 <__stack+0x153>
 3b0:	b3 ce       	rjmp	.-666    	; 0x118 <main+0x34>
	 
	bool checkEnable(){return (stateWork_ == enable_fan ? true : false);}                     // Проверяет, есть ли сигнал для включении вентилятора
		
	void disable(numberFan FAN)                                                               // Выключает вентилятор
	{                                                               //
		this->stateWork_ = disable_fan;                             // Обновить статус на "выключено"
 3b2:	d2 82       	std	Z+2, r13	; 0x02
		if (FAN == FAN1) PORTC &= ~(1 << PC3);                      // Если хотим выключить вентилятор1, записываем 0 в PC3
		else PORTC &= ~(1 << PC4);                                  // Если хотим выключить вентилятор2, записываем 0 в PC4
 3b4:	ac 98       	cbi	0x15, 4	; 21
					led_N2.blink(Led::LED_N2);                     // LED_N2 мигает
					led_A2.enable(Led::LED_A2);                    // LED_А2 горит
					if (timer.endTimer())                          // Суммарные 10 секунд теста истекло : смотрим результат для вентилятора 2
					{
						fan2.disable(Fan::FAN2);                   // Отключить вентилятор2
						if (fan2.getStatFeedback() == Fan::normal) // Вентилятор2 : норма
 3b6:	81 81       	ldd	r24, Z+1	; 0x01
 3b8:	81 30       	cpi	r24, 0x01	; 1
 3ba:	39 f4       	brne	.+14     	; 0x3ca <__stack+0x16b>
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 3bc:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <led_N2>
		switch (led)                                                 // 
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
 3c0:	97 9a       	sbi	0x12, 7	; 18
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 3c2:	d0 92 67 00 	sts	0x0067, r13	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
			break;                                                   //
			case LED_A2: PORTD &=  ~(1 << PD5);                      // LED_A2 : записать 0 в PD5
 3c6:	95 98       	cbi	0x12, 5	; 18
 3c8:	06 c0       	rjmp	.+12     	; 0x3d6 <__stack+0x177>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 3ca:	d0 92 69 00 	sts	0x0069, r13	; 0x800069 <led_N2>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
 3ce:	97 98       	cbi	0x12, 7	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 3d0:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
			break;                                                   //
			case LED_A2: PORTD |=  (1 << PD5);                       // LED_A2 : записать 1 в PD5
 3d4:	95 9a       	sbi	0x12, 5	; 18
	public:
	void setGlobalTime(unsigned int globalTime) {this->globalTime_ = globalTime;} // Установка глобальных часов (в прерывании таймера-счётчика0)
	
	unsigned int getGlobalTime(void)            {return globalTime_;}             // Метод получения текущего времени для его обновления в прерывании таймера-счётчика0
	
	void reset(void){flagTimer_ = true;}                                          // Сброс таймера в 0
 3d6:	dc 82       	std	Y+4, r13	; 0x04
						{
							led_N2.disable(Led::LED_N2);           // LED_N2 отключён
							led_A2.enable(Led::LED_A2);            // LED_А2 горит
						}
						timer.reset();                             // Сбрасываем таймер
						stateWork = STATE_WAIT_HEAT;               // Тесты окончены, преходим в состояня ожидания верхнего порога температуры
 3d8:	b0 92 76 00 	sts	0x0076, r11	; 0x800076 <stateWork>
 3dc:	9d ce       	rjmp	.-710    	; 0x118 <main+0x34>
				}
			} // Конец else STAND 52/54
			break; // конец case STATE_DIAGNOSTICS:
			
			case STATE_WAIT_HEAT:/*----------------------------- Статус "ОЖИДАНИЕ ВЕРХНЕГО ПОРОГА ТЕМПЕРАТУРЫ" -----------------------------*/
			if (gettemperature() >= HIGH_TEMPERATURE)              // Превысили верхний порог температуры
 3de:	7c de       	rcall	.-776    	; 0xd8 <_Z14gettemperaturev>
 3e0:	8d 3f       	cpi	r24, 0xFD	; 253
 3e2:	91 40       	sbci	r25, 0x01	; 1
 3e4:	0c f4       	brge	.+2      	; 0x3e8 <__stack+0x189>
 3e6:	ef c0       	rjmp	.+478    	; 0x5c6 <__LOCK_REGION_LENGTH__+0x1c6>
			{
				if (standType == STAND51) //------------------------- Для стойки 51
 3e8:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <standType>
 3ec:	81 11       	cpse	r24, r1
 3ee:	6c c0       	rjmp	.+216    	; 0x4c8 <__LOCK_REGION_LENGTH__+0xc8>
	
	void reset(void){flagTimer_ = true;}                                          // Сброс таймера в 0
	
	void start(unsigned int endTime)                                              // Метод начала отсчёта таймера
	{                                                                             //
		if(flagTimer_)                                                            // Если флаг таймера поднят, запоминаем время начала отсчёта:
 3f0:	8c 81       	ldd	r24, Y+4	; 0x04
 3f2:	88 23       	and	r24, r24
 3f4:	31 f0       	breq	.+12     	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
		{                                                                         //
			startTime_ = globalTime_;                                             // Запоминаем текущее время глобвльных часов
 3f6:	88 81       	ld	r24, Y
 3f8:	99 81       	ldd	r25, Y+1	; 0x01
 3fa:	9b 83       	std	Y+3, r25	; 0x03
 3fc:	8a 83       	std	Y+2, r24	; 0x02
			flagTimer_ = false;                                                   // Опускаем флаг таймера, начинаем считать:
 3fe:	1c 82       	std	Y+4, r1	; 0x04
 400:	34 c0       	rjmp	.+104    	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
		}                                                                         //
		else                                                                      // Если флаг таймера опущен
		{                                                                         //
			if (startTime_ + endTime > MAX_TIME )                                 // Суммарное время превышает максимальное число таймера
 402:	8a 81       	ldd	r24, Y+2	; 0x02
 404:	9b 81       	ldd	r25, Y+3	; 0x03
 406:	ac 01       	movw	r20, r24
 408:	48 57       	subi	r20, 0x78	; 120
 40a:	5c 4e       	sbci	r21, 0xEC	; 236
 40c:	4d 3f       	cpi	r20, 0xFD	; 253
 40e:	29 ee       	ldi	r18, 0xE9	; 233
 410:	52 07       	cpc	r21, r18
 412:	00 f1       	brcs	.+64     	; 0x454 <__LOCK_REGION_LENGTH__+0x54>
			{                                                                     //
				timeTimer_ = globalTime_ <= MAX_TIME ? globalTime_ - startTime_: MAX_TIME - startTime_ + globalTime_; // Запоминаем текущее время таймере
 414:	48 81       	ld	r20, Y
 416:	59 81       	ldd	r21, Y+1	; 0x01
 418:	4d 3f       	cpi	r20, 0xFD	; 253
 41a:	69 ee       	ldi	r22, 0xE9	; 233
 41c:	56 07       	cpc	r21, r22
 41e:	20 f4       	brcc	.+8      	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
 420:	9a 01       	movw	r18, r20
 422:	28 1b       	sub	r18, r24
 424:	39 0b       	sbc	r19, r25
 426:	05 c0       	rjmp	.+10     	; 0x432 <__LOCK_REGION_LENGTH__+0x32>
 428:	9a 01       	movw	r18, r20
 42a:	24 50       	subi	r18, 0x04	; 4
 42c:	36 41       	sbci	r19, 0x16	; 22
 42e:	28 1b       	sub	r18, r24
 430:	39 0b       	sbc	r19, r25
 432:	3e 83       	std	Y+6, r19	; 0x06
 434:	2d 83       	std	Y+5, r18	; 0x05
				if (globalTime_ == startTime_ - (MAX_TIME -  endTime) )  flagTimer_ = true;                           // Делаем поправку, переводя время окончания на начало часов,
 436:	60 e0       	ldi	r22, 0x00	; 0
 438:	70 e0       	ldi	r23, 0x00	; 0
 43a:	a0 e0       	ldi	r26, 0x00	; 0
 43c:	b0 e0       	ldi	r27, 0x00	; 0
 43e:	84 57       	subi	r24, 0x74	; 116
 440:	96 4d       	sbci	r25, 0xD6	; 214
 442:	a1 09       	sbc	r26, r1
 444:	b1 09       	sbc	r27, r1
 446:	48 17       	cp	r20, r24
 448:	59 07       	cpc	r21, r25
 44a:	6a 07       	cpc	r22, r26
 44c:	7b 07       	cpc	r23, r27
 44e:	69 f4       	brne	.+26     	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
 450:	dc 82       	std	Y+4, r13	; 0x04
 452:	0b c0       	rjmp	.+22     	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
			}                                                                     // Когда отсчёт окончен, поднимаем флажок для запоминания следующего времени
			else                                                                  // Если время окончания отсчёта не преышает максимум часов
			{                                                                     //
				timeTimer_ = globalTime_ - startTime_;                            // Запоминаем текущее время таймера
 454:	28 81       	ld	r18, Y
 456:	39 81       	ldd	r19, Y+1	; 0x01
 458:	f9 01       	movw	r30, r18
 45a:	e8 1b       	sub	r30, r24
 45c:	f9 0b       	sbc	r31, r25
 45e:	fe 83       	std	Y+6, r31	; 0x06
 460:	ed 83       	std	Y+5, r30	; 0x05
				if (globalTime_ == startTime_ + endTime) flagTimer_ = true;       // Если время окончания отсчёта не превышает максимум часов и отсчитали установленное время,поднимаем флажок
 462:	42 17       	cp	r20, r18
 464:	53 07       	cpc	r21, r19
 466:	09 f4       	brne	.+2      	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
 468:	dc 82       	std	Y+4, r13	; 0x04
	
	unsigned int getTimeToFail(){return timeToFail_;}                                         // Получает время ло принятия решения о неработоспособности вентиляторов
	
	void enable(numberFan FAN)                                                                // Включает вентилятор
	{                                                              //
		this->stateWork_ = enable_fan;                             // Обновить статус на "включено"
 46a:	f8 01       	movw	r30, r16
 46c:	12 82       	std	Z+2, r1	; 0x02
		if (FAN == FAN1) PORTC |=  (1 << PC3);                     // Если хотим включить вентилятор1, записываем 1 в PC3
 46e:	ab 9a       	sbi	0x15, 3	; 21
	
	unsigned int getTimeToFail(){return timeToFail_;}                                         // Получает время ло принятия решения о неработоспособности вентиляторов
	
	void enable(numberFan FAN)                                                                // Включает вентилятор
	{                                                              //
		this->stateWork_ = enable_fan;                             // Обновить статус на "включено"
 470:	f7 01       	movw	r30, r14
 472:	12 82       	std	Z+2, r1	; 0x02
		if (FAN == FAN1) PORTC |=  (1 << PC3);                     // Если хотим включить вентилятор1, записываем 1 в PC3
		else PORTC |=  (1 << PC4);                                 // Если хотим включить вентилятор2, записываем 1 в PC4
 474:	ac 9a       	sbi	0x15, 4	; 21
				if (standType == STAND51) //------------------------- Для стойки 51
				{
					timer.start(5000);                              // Включить таймер на 5 секунд
					fan1.enable(Fan::FAN1);                         // Включили все вентиляторы
					fan2.enable(Fan::FAN2);
					if (timer.endTimer())                           // Таймер закончил отсчёт
 476:	8c 81       	ldd	r24, Y+4	; 0x04
 478:	88 23       	and	r24, r24
 47a:	09 f4       	brne	.+2      	; 0x47e <__LOCK_REGION_LENGTH__+0x7e>
 47c:	4d ce       	rjmp	.-870    	; 0x118 <main+0x34>
					{
						if (fan1.getStatFeedback() == Fan::normal)  // Смотрим состояние : вентилятор1 в норме
 47e:	f8 01       	movw	r30, r16
 480:	81 81       	ldd	r24, Z+1	; 0x01
 482:	81 30       	cpi	r24, 0x01	; 1
 484:	41 f4       	brne	.+16     	; 0x496 <__LOCK_REGION_LENGTH__+0x96>
	void blink(numberLed led)                                                                  // Установть мерцание ветодиода
	{                                                                //
		/* Статус "мерцание" аппаратно  реализуется в прерывании     //
		таймера-счётчика 0                                           //
		*/                                                           //
		this->state_ = blink_led;                                    // Обновить статус на "мигание"
 486:	c0 92 6a 00 	sts	0x006A, r12	; 0x80006a <led_N1>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 48a:	d0 92 68 00 	sts	0x0068, r13	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
 48e:	94 98       	cbi	0x12, 4	; 18
					{
						if (fan1.getStatFeedback() == Fan::normal)  // Смотрим состояние : вентилятор1 в норме
						{
							led_N1.blink(Led::LED_N1);              // LED_N1 мигает
							led_A1.disable(Led::LED_A1);            // LED_A1 отключен
							stateWork = STATE_WAIT_HOLD;            // Перешли в ожидание нижнего порога температуры (после просмотра статуса венилятора2)
 490:	a0 92 76 00 	sts	0x0076, r10	; 0x800076 <stateWork>
 494:	06 c0       	rjmp	.+12     	; 0x4a2 <__LOCK_REGION_LENGTH__+0xa2>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 496:	d0 92 6a 00 	sts	0x006A, r13	; 0x80006a <led_N1>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
 49a:	96 98       	cbi	0x12, 6	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 49c:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
 4a0:	94 9a       	sbi	0x12, 4	; 18
						else                                        // Вентилятор 1 неисправен
						{
							led_N1.disable(Led::LED_N1);            // LED_N1 отключён
							led_A1.enable(Led::LED_A1);             // LED_A1 горит
						}
						if (fan2.getStatFeedback() == Fan::normal)  // Смотрим состояние : вентилятор2 в норме
 4a2:	f7 01       	movw	r30, r14
 4a4:	81 81       	ldd	r24, Z+1	; 0x01
 4a6:	81 30       	cpi	r24, 0x01	; 1
 4a8:	41 f4       	brne	.+16     	; 0x4ba <__LOCK_REGION_LENGTH__+0xba>
	void blink(numberLed led)                                                                  // Установть мерцание ветодиода
	{                                                                //
		/* Статус "мерцание" аппаратно  реализуется в прерывании     //
		таймера-счётчика 0                                           //
		*/                                                           //
		this->state_ = blink_led;                                    // Обновить статус на "мигание"
 4aa:	c0 92 69 00 	sts	0x0069, r12	; 0x800069 <led_N2>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 4ae:	d0 92 67 00 	sts	0x0067, r13	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
			break;                                                   //
			case LED_A2: PORTD &=  ~(1 << PD5);                      // LED_A2 : записать 0 в PD5
 4b2:	95 98       	cbi	0x12, 5	; 18
						}
						if (fan2.getStatFeedback() == Fan::normal)  // Смотрим состояние : вентилятор2 в норме
						{
							led_N2.blink(Led::LED_N2);              // LED_N2 мигает
							led_A2.disable(Led::LED_A2);            // LED_A2 отключен
							stateWork = STATE_WAIT_HOLD;            // Перешли в ожидание нижнего порога температуры
 4b4:	a0 92 76 00 	sts	0x0076, r10	; 0x800076 <stateWork>
 4b8:	2f ce       	rjmp	.-930    	; 0x118 <main+0x34>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 4ba:	d0 92 69 00 	sts	0x0069, r13	; 0x800069 <led_N2>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
 4be:	97 98       	cbi	0x12, 7	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 4c0:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
			break;                                                   //
			case LED_A2: PORTD |=  (1 << PD5);                       // LED_A2 : записать 1 в PD5
 4c4:	95 9a       	sbi	0x12, 5	; 18
 4c6:	28 ce       	rjmp	.-944    	; 0x118 <main+0x34>
	
	void reset(void){flagTimer_ = true;}                                          // Сброс таймера в 0
	
	void start(unsigned int endTime)                                              // Метод начала отсчёта таймера
	{                                                                             //
		if(flagTimer_)                                                            // Если флаг таймера поднят, запоминаем время начала отсчёта:
 4c8:	8c 81       	ldd	r24, Y+4	; 0x04
 4ca:	88 23       	and	r24, r24
 4cc:	31 f0       	breq	.+12     	; 0x4da <__LOCK_REGION_LENGTH__+0xda>
		{                                                                         //
			startTime_ = globalTime_;                                             // Запоминаем текущее время глобвльных часов
 4ce:	88 81       	ld	r24, Y
 4d0:	99 81       	ldd	r25, Y+1	; 0x01
 4d2:	9b 83       	std	Y+3, r25	; 0x03
 4d4:	8a 83       	std	Y+2, r24	; 0x02
			flagTimer_ = false;                                                   // Опускаем флаг таймера, начинаем считать:
 4d6:	1c 82       	std	Y+4, r1	; 0x04
 4d8:	34 c0       	rjmp	.+104    	; 0x542 <__LOCK_REGION_LENGTH__+0x142>
		}                                                                         //
		else                                                                      // Если флаг таймера опущен
		{                                                                         //
			if (startTime_ + endTime > MAX_TIME )                                 // Суммарное время превышает максимальное число таймера
 4da:	8a 81       	ldd	r24, Y+2	; 0x02
 4dc:	9b 81       	ldd	r25, Y+3	; 0x03
 4de:	ac 01       	movw	r20, r24
 4e0:	40 5f       	subi	r20, 0xF0	; 240
 4e2:	58 4d       	sbci	r21, 0xD8	; 216
 4e4:	4d 3f       	cpi	r20, 0xFD	; 253
 4e6:	f9 ee       	ldi	r31, 0xE9	; 233
 4e8:	5f 07       	cpc	r21, r31
 4ea:	00 f1       	brcs	.+64     	; 0x52c <__LOCK_REGION_LENGTH__+0x12c>
			{                                                                     //
				timeTimer_ = globalTime_ <= MAX_TIME ? globalTime_ - startTime_: MAX_TIME - startTime_ + globalTime_; // Запоминаем текущее время таймере
 4ec:	48 81       	ld	r20, Y
 4ee:	59 81       	ldd	r21, Y+1	; 0x01
 4f0:	4d 3f       	cpi	r20, 0xFD	; 253
 4f2:	29 ee       	ldi	r18, 0xE9	; 233
 4f4:	52 07       	cpc	r21, r18
 4f6:	20 f4       	brcc	.+8      	; 0x500 <__LOCK_REGION_LENGTH__+0x100>
 4f8:	9a 01       	movw	r18, r20
 4fa:	28 1b       	sub	r18, r24
 4fc:	39 0b       	sbc	r19, r25
 4fe:	05 c0       	rjmp	.+10     	; 0x50a <__LOCK_REGION_LENGTH__+0x10a>
 500:	9a 01       	movw	r18, r20
 502:	24 50       	subi	r18, 0x04	; 4
 504:	36 41       	sbci	r19, 0x16	; 22
 506:	28 1b       	sub	r18, r24
 508:	39 0b       	sbc	r19, r25
 50a:	3e 83       	std	Y+6, r19	; 0x06
 50c:	2d 83       	std	Y+5, r18	; 0x05
				if (globalTime_ == startTime_ - (MAX_TIME -  endTime) )  flagTimer_ = true;                           // Делаем поправку, переводя время окончания на начало часов,
 50e:	60 e0       	ldi	r22, 0x00	; 0
 510:	70 e0       	ldi	r23, 0x00	; 0
 512:	a0 e0       	ldi	r26, 0x00	; 0
 514:	b0 e0       	ldi	r27, 0x00	; 0
 516:	8c 5e       	subi	r24, 0xEC	; 236
 518:	92 4c       	sbci	r25, 0xC2	; 194
 51a:	a1 09       	sbc	r26, r1
 51c:	b1 09       	sbc	r27, r1
 51e:	48 17       	cp	r20, r24
 520:	59 07       	cpc	r21, r25
 522:	6a 07       	cpc	r22, r26
 524:	7b 07       	cpc	r23, r27
 526:	69 f4       	brne	.+26     	; 0x542 <__LOCK_REGION_LENGTH__+0x142>
 528:	dc 82       	std	Y+4, r13	; 0x04
 52a:	0b c0       	rjmp	.+22     	; 0x542 <__LOCK_REGION_LENGTH__+0x142>
			}                                                                     // Когда отсчёт окончен, поднимаем флажок для запоминания следующего времени
			else                                                                  // Если время окончания отсчёта не преышает максимум часов
			{                                                                     //
				timeTimer_ = globalTime_ - startTime_;                            // Запоминаем текущее время таймера
 52c:	28 81       	ld	r18, Y
 52e:	39 81       	ldd	r19, Y+1	; 0x01
 530:	b9 01       	movw	r22, r18
 532:	68 1b       	sub	r22, r24
 534:	79 0b       	sbc	r23, r25
 536:	7e 83       	std	Y+6, r23	; 0x06
 538:	6d 83       	std	Y+5, r22	; 0x05
				if (globalTime_ == startTime_ + endTime) flagTimer_ = true;       // Если время окончания отсчёта не превышает максимум часов и отсчитали установленное время,поднимаем флажок
 53a:	42 17       	cp	r20, r18
 53c:	53 07       	cpc	r21, r19
 53e:	09 f4       	brne	.+2      	; 0x542 <__LOCK_REGION_LENGTH__+0x142>
 540:	dc 82       	std	Y+4, r13	; 0x04
			}                                                                     //
		}                                                                         //
	}// конец void start(unsigned int endTime)    
	
	unsigned int getTimerTime(void) {return timeTimer_;}                          // Получить текущее время таймера
 542:	8d 81       	ldd	r24, Y+5	; 0x05
 544:	9e 81       	ldd	r25, Y+6	; 0x06
					}// конец if (timer.endTimer())
				}// конец if (standType == STAND51)
				else //--------------------------------------------Для стойки 52/54
				{
					timer.start(10000);                                 // Начать отсчёт 10ти секунд для поочерёдных тестов вентиляторов
					if (timer.getTimerTime() < 5000)                    // Пока идёт тест вентилятора1
 546:	88 38       	cpi	r24, 0x88	; 136
 548:	73 e1       	ldi	r23, 0x13	; 19
 54a:	97 07       	cpc	r25, r23
 54c:	38 f4       	brcc	.+14     	; 0x55c <__LOCK_REGION_LENGTH__+0x15c>
	
	unsigned int getTimeToFail(){return timeToFail_;}                                         // Получает время ло принятия решения о неработоспособности вентиляторов
	
	void enable(numberFan FAN)                                                                // Включает вентилятор
	{                                                              //
		this->stateWork_ = enable_fan;                             // Обновить статус на "включено"
 54e:	f8 01       	movw	r30, r16
 550:	12 82       	std	Z+2, r1	; 0x02
		if (FAN == FAN1) PORTC |=  (1 << PC3);                     // Если хотим включить вентилятор1, записываем 1 в PC3
 552:	ab 9a       	sbi	0x15, 3	; 21
	 
	bool checkEnable(){return (stateWork_ == enable_fan ? true : false);}                     // Проверяет, есть ли сигнал для включении вентилятора
		
	void disable(numberFan FAN)                                                               // Выключает вентилятор
	{                                                               //
		this->stateWork_ = disable_fan;                             // Обновить статус на "выключено"
 554:	f7 01       	movw	r30, r14
 556:	d2 82       	std	Z+2, r13	; 0x02
		if (FAN == FAN1) PORTC &= ~(1 << PC3);                      // Если хотим выключить вентилятор1, записываем 0 в PC3
		else PORTC &= ~(1 << PC4);                                  // Если хотим выключить вентилятор2, записываем 0 в PC4
 558:	ac 98       	cbi	0x15, 4	; 21
 55a:	de cd       	rjmp	.-1092   	; 0x118 <main+0x34>
					if (timer.getTimerTime() < 5000)                    // Пока идёт тест вентилятора1
					{
						fan1.enable(Fan::FAN1);                         // Вентилятор1 включён
						fan2.disable(Fan::FAN2);                        // Вентилятор2 отключён
					}
					else if (timer.getTimerTime() == 5000)              // 5 секунд теста вентилятора 1 прошли
 55c:	88 38       	cpi	r24, 0x88	; 136
 55e:	93 41       	sbci	r25, 0x13	; 19
 560:	b1 f4       	brne	.+44     	; 0x58e <__LOCK_REGION_LENGTH__+0x18e>
					{
						
						if (fan1.getStatFeedback() == Fan::normal)      // Смотрим состояние вентилятора 1 : норма
 562:	f8 01       	movw	r30, r16
 564:	81 81       	ldd	r24, Z+1	; 0x01
 566:	81 30       	cpi	r24, 0x01	; 1
 568:	41 f4       	brne	.+16     	; 0x57a <__LOCK_REGION_LENGTH__+0x17a>
	void blink(numberLed led)                                                                  // Установть мерцание ветодиода
	{                                                                //
		/* Статус "мерцание" аппаратно  реализуется в прерывании     //
		таймера-счётчика 0                                           //
		*/                                                           //
		this->state_ = blink_led;                                    // Обновить статус на "мигание"
 56a:	c0 92 6a 00 	sts	0x006A, r12	; 0x80006a <led_N1>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 56e:	d0 92 68 00 	sts	0x0068, r13	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
 572:	94 98       	cbi	0x12, 4	; 18
						
						if (fan1.getStatFeedback() == Fan::normal)      // Смотрим состояние вентилятора 1 : норма
						{
							led_N1.blink(Led::LED_N1);                  // LED_N1 мигает
							led_A1.disable(Led::LED_A1);                // LED_A1 отключён
							stateWork = STATE_WAIT_HOLD;                // Переход в состояние "Ожидание нижнего порога температур"
 574:	a0 92 76 00 	sts	0x0076, r10	; 0x800076 <stateWork>
 578:	cf cd       	rjmp	.-1122   	; 0x118 <main+0x34>
	 
	bool checkEnable(){return (stateWork_ == enable_fan ? true : false);}                     // Проверяет, есть ли сигнал для включении вентилятора
		
	void disable(numberFan FAN)                                                               // Выключает вентилятор
	{                                                               //
		this->stateWork_ = disable_fan;                             // Обновить статус на "выключено"
 57a:	f8 01       	movw	r30, r16
 57c:	d2 82       	std	Z+2, r13	; 0x02
		if (FAN == FAN1) PORTC &= ~(1 << PC3);                      // Если хотим выключить вентилятор1, записываем 0 в PC3
 57e:	ab 98       	cbi	0x15, 3	; 21
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 580:	d0 92 6a 00 	sts	0x006A, r13	; 0x80006a <led_N1>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
 584:	96 98       	cbi	0x12, 6	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 586:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
 58a:	94 9a       	sbi	0x12, 4	; 18
 58c:	c5 cd       	rjmp	.-1142   	; 0x118 <main+0x34>
	
	unsigned int getTimeToFail(){return timeToFail_;}                                         // Получает время ло принятия решения о неработоспособности вентиляторов
	
	void enable(numberFan FAN)                                                                // Включает вентилятор
	{                                                              //
		this->stateWork_ = enable_fan;                             // Обновить статус на "включено"
 58e:	f7 01       	movw	r30, r14
 590:	12 82       	std	Z+2, r1	; 0x02
		if (FAN == FAN1) PORTC |=  (1 << PC3);                     // Если хотим включить вентилятор1, записываем 1 в PC3
		else PORTC |=  (1 << PC4);                                 // Если хотим включить вентилятор2, записываем 1 в PC4
 592:	ac 9a       	sbi	0x15, 4	; 21
						}
					}
					else                                                // 5 секунд теста вентилятора1 истекло и он неисправен, то начинаем тест вентилятора 2
					{
						fan2.enable(Fan::FAN2);                         // Включить вентилятор2
						if (timer.endTimer())                           // Суммарные 10 секунд теста истекло : смотрим результат
 594:	8c 81       	ldd	r24, Y+4	; 0x04
 596:	88 23       	and	r24, r24
 598:	09 f4       	brne	.+2      	; 0x59c <__LOCK_REGION_LENGTH__+0x19c>
 59a:	be cd       	rjmp	.-1156   	; 0x118 <main+0x34>
						{
							if (fan2.getStatFeedback() == Fan::normal)  // Венилятор2 : норма
 59c:	81 81       	ldd	r24, Z+1	; 0x01
 59e:	81 30       	cpi	r24, 0x01	; 1
 5a0:	41 f4       	brne	.+16     	; 0x5b2 <__LOCK_REGION_LENGTH__+0x1b2>
	void blink(numberLed led)                                                                  // Установть мерцание ветодиода
	{                                                                //
		/* Статус "мерцание" аппаратно  реализуется в прерывании     //
		таймера-счётчика 0                                           //
		*/                                                           //
		this->state_ = blink_led;                                    // Обновить статус на "мигание"
 5a2:	c0 92 69 00 	sts	0x0069, r12	; 0x800069 <led_N2>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 5a6:	d0 92 67 00 	sts	0x0067, r13	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
			break;                                                   //
			case LED_A2: PORTD &=  ~(1 << PD5);                      // LED_A2 : записать 0 в PD5
 5aa:	95 98       	cbi	0x12, 5	; 18
						{
							if (fan2.getStatFeedback() == Fan::normal)  // Венилятор2 : норма
							{
								led_N2.blink(Led::LED_N2);              // LED_N2 мигает
								led_A2.disable(Led::LED_A2);            // LED_A2 отключён
								stateWork = STATE_WAIT_HOLD;            // Переход в состояние "Ожидание нижнего порога температур"
 5ac:	a0 92 76 00 	sts	0x0076, r10	; 0x800076 <stateWork>
 5b0:	b3 cd       	rjmp	.-1178   	; 0x118 <main+0x34>
	 
	bool checkEnable(){return (stateWork_ == enable_fan ? true : false);}                     // Проверяет, есть ли сигнал для включении вентилятора
		
	void disable(numberFan FAN)                                                               // Выключает вентилятор
	{                                                               //
		this->stateWork_ = disable_fan;                             // Обновить статус на "выключено"
 5b2:	f7 01       	movw	r30, r14
 5b4:	d2 82       	std	Z+2, r13	; 0x02
		if (FAN == FAN1) PORTC &= ~(1 << PC3);                      // Если хотим выключить вентилятор1, записываем 0 в PC3
		else PORTC &= ~(1 << PC4);                                  // Если хотим выключить вентилятор2, записываем 0 в PC4
 5b6:	ac 98       	cbi	0x15, 4	; 21
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 5b8:	d0 92 69 00 	sts	0x0069, r13	; 0x800069 <led_N2>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
 5bc:	97 98       	cbi	0x12, 7	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 5be:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
			break;                                                   //
			case LED_A2: PORTD |=  (1 << PD5);                       // LED_A2 : записать 1 в PD5
 5c2:	95 9a       	sbi	0x12, 5	; 18
 5c4:	a9 cd       	rjmp	.-1198   	; 0x118 <main+0x34>
	 
	bool checkEnable(){return (stateWork_ == enable_fan ? true : false);}                     // Проверяет, есть ли сигнал для включении вентилятора
		
	void disable(numberFan FAN)                                                               // Выключает вентилятор
	{                                                               //
		this->stateWork_ = disable_fan;                             // Обновить статус на "выключено"
 5c6:	f8 01       	movw	r30, r16
 5c8:	d2 82       	std	Z+2, r13	; 0x02
		if (FAN == FAN1) PORTC &= ~(1 << PC3);                      // Если хотим выключить вентилятор1, записываем 0 в PC3
 5ca:	ab 98       	cbi	0x15, 3	; 21
	 
	bool checkEnable(){return (stateWork_ == enable_fan ? true : false);}                     // Проверяет, есть ли сигнал для включении вентилятора
		
	void disable(numberFan FAN)                                                               // Выключает вентилятор
	{                                                               //
		this->stateWork_ = disable_fan;                             // Обновить статус на "выключено"
 5cc:	f7 01       	movw	r30, r14
 5ce:	d2 82       	std	Z+2, r13	; 0x02
		if (FAN == FAN1) PORTC &= ~(1 << PC3);                      // Если хотим выключить вентилятор1, записываем 0 в PC3
		else PORTC &= ~(1 << PC4);                                  // Если хотим выключить вентилятор2, записываем 0 в PC4
 5d0:	ac 98       	cbi	0x15, 4	; 21
 5d2:	a2 cd       	rjmp	.-1212   	; 0x118 <main+0x34>
				fan2.disable(Fan::FAN2);
			}
			break;  // конец case STATE_WAIT_HEAT:
			
			case STATE_WAIT_HOLD:/*----------------------------- Статус "ОЖИДАНИЕ НИЖНЕГО ПОРОГА ТЕМПЕРАТУРЫ --------------------------------*/
			if (gettemperature() >= LOW_TEMPERATURE)                    // Нижний порог не достигнут - процесс охлаждения
 5d4:	81 dd       	rcall	.-1278   	; 0xd8 <_Z14gettemperaturev>
 5d6:	81 3d       	cpi	r24, 0xD1	; 209
 5d8:	91 40       	sbci	r25, 0x01	; 1
 5da:	0c f4       	brge	.+2      	; 0x5de <__LOCK_REGION_LENGTH__+0x1de>
 5dc:	c6 c0       	rjmp	.+396    	; 0x76a <__LOCK_REGION_LENGTH__+0x36a>
			{
				if (standType == STAND51) //----------------------------- Для стойки 51
 5de:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <standType>
 5e2:	81 11       	cpse	r24, r1
 5e4:	27 c0       	rjmp	.+78     	; 0x634 <__LOCK_REGION_LENGTH__+0x234>
	
	unsigned int getTimeToFail(){return timeToFail_;}                                         // Получает время ло принятия решения о неработоспособности вентиляторов
	
	void enable(numberFan FAN)                                                                // Включает вентилятор
	{                                                              //
		this->stateWork_ = enable_fan;                             // Обновить статус на "включено"
 5e6:	f8 01       	movw	r30, r16
 5e8:	12 82       	std	Z+2, r1	; 0x02
		if (FAN == FAN1) PORTC |=  (1 << PC3);                     // Если хотим включить вентилятор1, записываем 1 в PC3
 5ea:	ab 9a       	sbi	0x15, 3	; 21
	
	unsigned int getTimeToFail(){return timeToFail_;}                                         // Получает время ло принятия решения о неработоспособности вентиляторов
	
	void enable(numberFan FAN)                                                                // Включает вентилятор
	{                                                              //
		this->stateWork_ = enable_fan;                             // Обновить статус на "включено"
 5ec:	f7 01       	movw	r30, r14
 5ee:	12 82       	std	Z+2, r1	; 0x02
		if (FAN == FAN1) PORTC |=  (1 << PC3);                     // Если хотим включить вентилятор1, записываем 1 в PC3
 5f0:	ab 9a       	sbi	0x15, 3	; 21
			{
				if (standType == STAND51) //----------------------------- Для стойки 51
				{
					fan1.enable(Fan::FAN1);                             // Оба вентилятора всегда включены
					fan2.enable(Fan::FAN1);
					if (fan1.getStatFeedback() == Fan::normal)          // Вентилятор1 : норма
 5f2:	f8 01       	movw	r30, r16
 5f4:	81 81       	ldd	r24, Z+1	; 0x01
 5f6:	81 30       	cpi	r24, 0x01	; 1
 5f8:	31 f4       	brne	.+12     	; 0x606 <__LOCK_REGION_LENGTH__+0x206>
	void blink(numberLed led)                                                                  // Установть мерцание ветодиода
	{                                                                //
		/* Статус "мерцание" аппаратно  реализуется в прерывании     //
		таймера-счётчика 0                                           //
		*/                                                           //
		this->state_ = blink_led;                                    // Обновить статус на "мигание"
 5fa:	c0 92 6a 00 	sts	0x006A, r12	; 0x80006a <led_N1>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 5fe:	d0 92 68 00 	sts	0x0068, r13	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
 602:	94 98       	cbi	0x12, 4	; 18
 604:	06 c0       	rjmp	.+12     	; 0x612 <__LOCK_REGION_LENGTH__+0x212>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 606:	d0 92 6a 00 	sts	0x006A, r13	; 0x80006a <led_N1>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
 60a:	96 98       	cbi	0x12, 6	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 60c:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
 610:	94 9a       	sbi	0x12, 4	; 18
					{
						led_N1.disable(Led::LED_N1);                    // LED_N1 отключён
						led_A1.enable(Led::LED_A1);                     // LED_A1 горит
					}
					
					if (fan2.getStatFeedback() == Fan::normal)          // Вентилятор2 : норма
 612:	f7 01       	movw	r30, r14
 614:	81 81       	ldd	r24, Z+1	; 0x01
 616:	81 30       	cpi	r24, 0x01	; 1
 618:	31 f4       	brne	.+12     	; 0x626 <__LOCK_REGION_LENGTH__+0x226>
	void blink(numberLed led)                                                                  // Установть мерцание ветодиода
	{                                                                //
		/* Статус "мерцание" аппаратно  реализуется в прерывании     //
		таймера-счётчика 0                                           //
		*/                                                           //
		this->state_ = blink_led;                                    // Обновить статус на "мигание"
 61a:	c0 92 69 00 	sts	0x0069, r12	; 0x800069 <led_N2>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 61e:	d0 92 67 00 	sts	0x0067, r13	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
			break;                                                   //
			case LED_A2: PORTD &=  ~(1 << PD5);                      // LED_A2 : записать 0 в PD5
 622:	95 98       	cbi	0x12, 5	; 18
 624:	79 cd       	rjmp	.-1294   	; 0x118 <main+0x34>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 626:	d0 92 69 00 	sts	0x0069, r13	; 0x800069 <led_N2>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
 62a:	97 98       	cbi	0x12, 7	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 62c:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
			break;                                                   //
			case LED_A2: PORTD |=  (1 << PD5);                       // LED_A2 : записать 1 в PD5
 630:	95 9a       	sbi	0x12, 5	; 18
 632:	72 cd       	rjmp	.-1308   	; 0x118 <main+0x34>
	
	void reset(void){flagTimer_ = true;}                                          // Сброс таймера в 0
	
	void start(unsigned int endTime)                                              // Метод начала отсчёта таймера
	{                                                                             //
		if(flagTimer_)                                                            // Если флаг таймера поднят, запоминаем время начала отсчёта:
 634:	8c 81       	ldd	r24, Y+4	; 0x04
 636:	88 23       	and	r24, r24
 638:	31 f0       	breq	.+12     	; 0x646 <__LOCK_REGION_LENGTH__+0x246>
		{                                                                         //
			startTime_ = globalTime_;                                             // Запоминаем текущее время глобвльных часов
 63a:	88 81       	ld	r24, Y
 63c:	99 81       	ldd	r25, Y+1	; 0x01
 63e:	9b 83       	std	Y+3, r25	; 0x03
 640:	8a 83       	std	Y+2, r24	; 0x02
			flagTimer_ = false;                                                   // Опускаем флаг таймера, начинаем считать:
 642:	1c 82       	std	Y+4, r1	; 0x04
 644:	69 cd       	rjmp	.-1326   	; 0x118 <main+0x34>
		}                                                                         //
		else                                                                      // Если флаг таймера опущен
		{                                                                         //
			if (startTime_ + endTime > MAX_TIME )                                 // Суммарное время превышает максимальное число таймера
 646:	8a 81       	ldd	r24, Y+2	; 0x02
 648:	9b 81       	ldd	r25, Y+3	; 0x03
 64a:	ac 01       	movw	r20, r24
 64c:	48 57       	subi	r20, 0x78	; 120
 64e:	5c 4e       	sbci	r21, 0xEC	; 236
 650:	4d 3f       	cpi	r20, 0xFD	; 253
 652:	f9 ee       	ldi	r31, 0xE9	; 233
 654:	5f 07       	cpc	r21, r31
 656:	08 f1       	brcs	.+66     	; 0x69a <__LOCK_REGION_LENGTH__+0x29a>
			{                                                                     //
				timeTimer_ = globalTime_ <= MAX_TIME ? globalTime_ - startTime_: MAX_TIME - startTime_ + globalTime_; // Запоминаем текущее время таймере
 658:	48 81       	ld	r20, Y
 65a:	59 81       	ldd	r21, Y+1	; 0x01
 65c:	4d 3f       	cpi	r20, 0xFD	; 253
 65e:	29 ee       	ldi	r18, 0xE9	; 233
 660:	52 07       	cpc	r21, r18
 662:	20 f4       	brcc	.+8      	; 0x66c <__LOCK_REGION_LENGTH__+0x26c>
 664:	9a 01       	movw	r18, r20
 666:	28 1b       	sub	r18, r24
 668:	39 0b       	sbc	r19, r25
 66a:	05 c0       	rjmp	.+10     	; 0x676 <__LOCK_REGION_LENGTH__+0x276>
 66c:	9a 01       	movw	r18, r20
 66e:	24 50       	subi	r18, 0x04	; 4
 670:	36 41       	sbci	r19, 0x16	; 22
 672:	28 1b       	sub	r18, r24
 674:	39 0b       	sbc	r19, r25
 676:	3e 83       	std	Y+6, r19	; 0x06
 678:	2d 83       	std	Y+5, r18	; 0x05
				if (globalTime_ == startTime_ - (MAX_TIME -  endTime) )  flagTimer_ = true;                           // Делаем поправку, переводя время окончания на начало часов,
 67a:	60 e0       	ldi	r22, 0x00	; 0
 67c:	70 e0       	ldi	r23, 0x00	; 0
 67e:	a0 e0       	ldi	r26, 0x00	; 0
 680:	b0 e0       	ldi	r27, 0x00	; 0
 682:	84 57       	subi	r24, 0x74	; 116
 684:	96 4d       	sbci	r25, 0xD6	; 214
 686:	a1 09       	sbc	r26, r1
 688:	b1 09       	sbc	r27, r1
 68a:	48 17       	cp	r20, r24
 68c:	59 07       	cpc	r21, r25
 68e:	6a 07       	cpc	r22, r26
 690:	7b 07       	cpc	r23, r27
 692:	09 f0       	breq	.+2      	; 0x696 <__LOCK_REGION_LENGTH__+0x296>
 694:	41 cd       	rjmp	.-1406   	; 0x118 <main+0x34>
 696:	dc 82       	std	Y+4, r13	; 0x04
 698:	8e c0       	rjmp	.+284    	; 0x7b6 <__LOCK_REGION_LENGTH__+0x3b6>
			}                                                                     // Когда отсчёт окончен, поднимаем флажок для запоминания следующего времени
			else                                                                  // Если время окончания отсчёта не преышает максимум часов
			{                                                                     //
				timeTimer_ = globalTime_ - startTime_;                            // Запоминаем текущее время таймера
 69a:	28 81       	ld	r18, Y
 69c:	39 81       	ldd	r19, Y+1	; 0x01
 69e:	b9 01       	movw	r22, r18
 6a0:	68 1b       	sub	r22, r24
 6a2:	79 0b       	sbc	r23, r25
 6a4:	7e 83       	std	Y+6, r23	; 0x06
 6a6:	6d 83       	std	Y+5, r22	; 0x05
				if (globalTime_ == startTime_ + endTime) flagTimer_ = true;       // Если время окончания отсчёта не превышает максимум часов и отсчитали установленное время,поднимаем флажок
 6a8:	42 17       	cp	r20, r18
 6aa:	53 07       	cpc	r21, r19
 6ac:	09 f0       	breq	.+2      	; 0x6b0 <__LOCK_REGION_LENGTH__+0x2b0>
 6ae:	34 cd       	rjmp	.-1432   	; 0x118 <main+0x34>
 6b0:	dc 82       	std	Y+4, r13	; 0x04
 6b2:	81 c0       	rjmp	.+258    	; 0x7b6 <__LOCK_REGION_LENGTH__+0x3b6>
					if(timer.endTimer())                                                          // После окончания отсчёта 5ти секунд
					{
						Fan::stateFeedbackFan stateFeedbackFan1 = fan1.getStatFeedback();         // Записываем статсы обратных связей в локальные переменные с целью оптимизации
						Fan::stateFeedbackFan stateFeedbackFan2 = fan2.getStatFeedback();
						
						if (stateFeedbackFan1 == Fan::normal && stateFeedbackFan2 == Fan::normal) // Оба вентилятора в норме
 6b4:	81 30       	cpi	r24, 0x01	; 1
 6b6:	91 f4       	brne	.+36     	; 0x6dc <__LOCK_REGION_LENGTH__+0x2dc>
	 
	bool checkEnable(){return (stateWork_ == enable_fan ? true : false);}                     // Проверяет, есть ли сигнал для включении вентилятора
		
	void disable(numberFan FAN)                                                               // Выключает вентилятор
	{                                                               //
		this->stateWork_ = disable_fan;                             // Обновить статус на "выключено"
 6b8:	f7 01       	movw	r30, r14
 6ba:	d2 82       	std	Z+2, r13	; 0x02
		if (FAN == FAN1) PORTC &= ~(1 << PC3);                      // Если хотим выключить вентилятор1, записываем 0 в PC3
		else PORTC &= ~(1 << PC4);                                  // Если хотим выключить вентилятор2, записываем 0 в PC4
 6bc:	ac 98       	cbi	0x15, 4	; 21
	
	unsigned int getTimeToFail(){return timeToFail_;}                                         // Получает время ло принятия решения о неработоспособности вентиляторов
	
	void enable(numberFan FAN)                                                                // Включает вентилятор
	{                                                              //
		this->stateWork_ = enable_fan;                             // Обновить статус на "включено"
 6be:	f8 01       	movw	r30, r16
 6c0:	12 82       	std	Z+2, r1	; 0x02
		if (FAN == FAN1) PORTC |=  (1 << PC3);                     // Если хотим включить вентилятор1, записываем 1 в PC3
 6c2:	ab 9a       	sbi	0x15, 3	; 21
	void blink(numberLed led)                                                                  // Установть мерцание ветодиода
	{                                                                //
		/* Статус "мерцание" аппаратно  реализуется в прерывании     //
		таймера-счётчика 0                                           //
		*/                                                           //
		this->state_ = blink_led;                                    // Обновить статус на "мигание"
 6c4:	c0 92 6a 00 	sts	0x006A, r12	; 0x80006a <led_N1>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 6c8:	d0 92 68 00 	sts	0x0068, r13	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
 6cc:	94 98       	cbi	0x12, 4	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 6ce:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <led_N2>
		switch (led)                                                 // 
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
 6d2:	97 9a       	sbi	0x12, 7	; 18
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 6d4:	d0 92 67 00 	sts	0x0067, r13	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
			break;                                                   //
			case LED_A2: PORTD &=  ~(1 << PD5);                      // LED_A2 : записать 0 в PD5
 6d8:	95 98       	cbi	0x12, 5	; 18
 6da:	1e cd       	rjmp	.-1476   	; 0x118 <main+0x34>
							led_N1.blink(Led::LED_N1);             // LED_N1 мигает
							led_A1.disable(Led::LED_A1);           // LED_A1 отключён
							led_N2.enable(Led::LED_N2);            // LED_N2 горит
							led_A2.disable(Led::LED_A2);           // LED_A2 отключён
						}
						else if(stateFeedbackFan1 == Fan::normal && stateFeedbackFan2 == Fan::fail) // В норме только вентилятор1
 6dc:	81 11       	cpse	r24, r1
 6de:	28 c0       	rjmp	.+80     	; 0x730 <__LOCK_REGION_LENGTH__+0x330>
	 
	bool checkEnable(){return (stateWork_ == enable_fan ? true : false);}                     // Проверяет, есть ли сигнал для включении вентилятора
		
	void disable(numberFan FAN)                                                               // Выключает вентилятор
	{                                                               //
		this->stateWork_ = disable_fan;                             // Обновить статус на "выключено"
 6e0:	f7 01       	movw	r30, r14
 6e2:	d2 82       	std	Z+2, r13	; 0x02
		if (FAN == FAN1) PORTC &= ~(1 << PC3);                      // Если хотим выключить вентилятор1, записываем 0 в PC3
		else PORTC &= ~(1 << PC4);                                  // Если хотим выключить вентилятор2, записываем 0 в PC4
 6e4:	ac 98       	cbi	0x15, 4	; 21
	
	unsigned int getTimeToFail(){return timeToFail_;}                                         // Получает время ло принятия решения о неработоспособности вентиляторов
	
	void enable(numberFan FAN)                                                                // Включает вентилятор
	{                                                              //
		this->stateWork_ = enable_fan;                             // Обновить статус на "включено"
 6e6:	f8 01       	movw	r30, r16
 6e8:	12 82       	std	Z+2, r1	; 0x02
		if (FAN == FAN1) PORTC |=  (1 << PC3);                     // Если хотим включить вентилятор1, записываем 1 в PC3
 6ea:	ab 9a       	sbi	0x15, 3	; 21
	void blink(numberLed led)                                                                  // Установть мерцание ветодиода
	{                                                                //
		/* Статус "мерцание" аппаратно  реализуется в прерывании     //
		таймера-счётчика 0                                           //
		*/                                                           //
		this->state_ = blink_led;                                    // Обновить статус на "мигание"
 6ec:	c0 92 6a 00 	sts	0x006A, r12	; 0x80006a <led_N1>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 6f0:	d0 92 68 00 	sts	0x0068, r13	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
 6f4:	94 98       	cbi	0x12, 4	; 18
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 6f6:	d0 92 69 00 	sts	0x0069, r13	; 0x800069 <led_N2>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
 6fa:	97 98       	cbi	0x12, 7	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 6fc:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
			break;                                                   //
			case LED_A2: PORTD |=  (1 << PD5);                       // LED_A2 : записать 1 в PD5
 700:	95 9a       	sbi	0x12, 5	; 18
 702:	0a cd       	rjmp	.-1516   	; 0x118 <main+0x34>
							led_N1.blink(Led::LED_N1);             // LED_N1 мигает
							led_A1.disable(Led::LED_A1);           // LED_A1 отключён
							led_N2.disable(Led::LED_N2);           // LED_N2 отключён
							led_A2.enable(Led::LED_A2);            // LED_A2 горит
						}
						else if (stateFeedbackFan1 == Fan::fail && stateFeedbackFan2 == Fan::normal) // В норме только вентилятор2
 704:	91 11       	cpse	r25, r1
 706:	14 c0       	rjmp	.+40     	; 0x730 <__LOCK_REGION_LENGTH__+0x330>
 708:	81 30       	cpi	r24, 0x01	; 1
 70a:	91 f4       	brne	.+36     	; 0x730 <__LOCK_REGION_LENGTH__+0x330>
	 
	bool checkEnable(){return (stateWork_ == enable_fan ? true : false);}                     // Проверяет, есть ли сигнал для включении вентилятора
		
	void disable(numberFan FAN)                                                               // Выключает вентилятор
	{                                                               //
		this->stateWork_ = disable_fan;                             // Обновить статус на "выключено"
 70c:	f8 01       	movw	r30, r16
 70e:	d2 82       	std	Z+2, r13	; 0x02
		if (FAN == FAN1) PORTC &= ~(1 << PC3);                      // Если хотим выключить вентилятор1, записываем 0 в PC3
 710:	ab 98       	cbi	0x15, 3	; 21
	
	unsigned int getTimeToFail(){return timeToFail_;}                                         // Получает время ло принятия решения о неработоспособности вентиляторов
	
	void enable(numberFan FAN)                                                                // Включает вентилятор
	{                                                              //
		this->stateWork_ = enable_fan;                             // Обновить статус на "включено"
 712:	f7 01       	movw	r30, r14
 714:	12 82       	std	Z+2, r1	; 0x02
		if (FAN == FAN1) PORTC |=  (1 << PC3);                     // Если хотим включить вентилятор1, записываем 1 в PC3
		else PORTC |=  (1 << PC4);                                 // Если хотим включить вентилятор2, записываем 1 в PC4
 716:	ac 9a       	sbi	0x15, 4	; 21
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 718:	d0 92 6a 00 	sts	0x006A, r13	; 0x80006a <led_N1>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
 71c:	96 98       	cbi	0x12, 6	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 71e:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
 722:	94 9a       	sbi	0x12, 4	; 18
	void blink(numberLed led)                                                                  // Установть мерцание ветодиода
	{                                                                //
		/* Статус "мерцание" аппаратно  реализуется в прерывании     //
		таймера-счётчика 0                                           //
		*/                                                           //
		this->state_ = blink_led;                                    // Обновить статус на "мигание"
 724:	c0 92 69 00 	sts	0x0069, r12	; 0x800069 <led_N2>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 728:	d0 92 67 00 	sts	0x0067, r13	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
			break;                                                   //
			case LED_A2: PORTD &=  ~(1 << PD5);                      // LED_A2 : записать 0 в PD5
 72c:	95 98       	cbi	0x12, 5	; 18
 72e:	f4 cc       	rjmp	.-1560   	; 0x118 <main+0x34>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 730:	d0 92 6a 00 	sts	0x006A, r13	; 0x80006a <led_N1>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
 734:	96 98       	cbi	0x12, 6	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 736:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
 73a:	94 9a       	sbi	0x12, 4	; 18
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 73c:	d0 92 69 00 	sts	0x0069, r13	; 0x800069 <led_N2>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
 740:	97 98       	cbi	0x12, 7	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 742:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
			break;                                                   //
			case LED_A2: PORTD |=  (1 << PD5);                       // LED_A2 : записать 1 в PD5
 746:	95 9a       	sbi	0x12, 5	; 18
						{
							led_N1.disable(Led::LED_N1);           // LED_N1 отключён
							led_A1.enable(Led::LED_A1);            // LED_A1 горит
							led_N2.disable(Led::LED_N2);           // LED_N2 отключён
							led_A2.enable(Led::LED_A2);            // LED_A2 горит
							if (fan1.checkEnable())                // Проверяем, есть ли сигнал включения для вентилятора1
 748:	f8 01       	movw	r30, r16
 74a:	82 81       	ldd	r24, Z+2	; 0x02
 74c:	81 11       	cpse	r24, r1
 74e:	06 c0       	rjmp	.+12     	; 0x75c <__LOCK_REGION_LENGTH__+0x35c>
	 
	bool checkEnable(){return (stateWork_ == enable_fan ? true : false);}                     // Проверяет, есть ли сигнал для включении вентилятора
		
	void disable(numberFan FAN)                                                               // Выключает вентилятор
	{                                                               //
		this->stateWork_ = disable_fan;                             // Обновить статус на "выключено"
 750:	d2 82       	std	Z+2, r13	; 0x02
		if (FAN == FAN1) PORTC &= ~(1 << PC3);                      // Если хотим выключить вентилятор1, записываем 0 в PC3
 752:	ab 98       	cbi	0x15, 3	; 21
	
	unsigned int getTimeToFail(){return timeToFail_;}                                         // Получает время ло принятия решения о неработоспособности вентиляторов
	
	void enable(numberFan FAN)                                                                // Включает вентилятор
	{                                                              //
		this->stateWork_ = enable_fan;                             // Обновить статус на "включено"
 754:	f7 01       	movw	r30, r14
 756:	12 82       	std	Z+2, r1	; 0x02
		if (FAN == FAN1) PORTC |=  (1 << PC3);                     // Если хотим включить вентилятор1, записываем 1 в PC3
		else PORTC |=  (1 << PC4);                                 // Если хотим включить вентилятор2, записываем 1 в PC4
 758:	ac 9a       	sbi	0x15, 4	; 21
 75a:	de cc       	rjmp	.-1604   	; 0x118 <main+0x34>
	
	unsigned int getTimeToFail(){return timeToFail_;}                                         // Получает время ло принятия решения о неработоспособности вентиляторов
	
	void enable(numberFan FAN)                                                                // Включает вентилятор
	{                                                              //
		this->stateWork_ = enable_fan;                             // Обновить статус на "включено"
 75c:	f8 01       	movw	r30, r16
 75e:	12 82       	std	Z+2, r1	; 0x02
		if (FAN == FAN1) PORTC |=  (1 << PC3);                     // Если хотим включить вентилятор1, записываем 1 в PC3
 760:	ab 9a       	sbi	0x15, 3	; 21
	 
	bool checkEnable(){return (stateWork_ == enable_fan ? true : false);}                     // Проверяет, есть ли сигнал для включении вентилятора
		
	void disable(numberFan FAN)                                                               // Выключает вентилятор
	{                                                               //
		this->stateWork_ = disable_fan;                             // Обновить статус на "выключено"
 762:	f7 01       	movw	r30, r14
 764:	d2 82       	std	Z+2, r13	; 0x02
		if (FAN == FAN1) PORTC &= ~(1 << PC3);                      // Если хотим выключить вентилятор1, записываем 0 в PC3
		else PORTC &= ~(1 << PC4);                                  // Если хотим выключить вентилятор2, записываем 0 в PC4
 766:	ac 98       	cbi	0x15, 4	; 21
 768:	d7 cc       	rjmp	.-1618   	; 0x118 <main+0x34>
					} // конец if(timer.endTimer())     
				} // конец else для стойки 51_54
			} // конец if (gettemperature() >= LOW_TEMPERATURE)   
			else                                                   // Достигли нижнего порога температуры
			{
				if (fan1.getStatFeedback() == Fan::normal)         // Вентилятор1 : норма
 76a:	f8 01       	movw	r30, r16
 76c:	81 81       	ldd	r24, Z+1	; 0x01
 76e:	81 30       	cpi	r24, 0x01	; 1
 770:	39 f4       	brne	.+14     	; 0x780 <__LOCK_REGION_LENGTH__+0x380>
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 772:	10 92 6a 00 	sts	0x006A, r1	; 0x80006a <led_N1>
		switch (led)                                                 // 
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
 776:	96 9a       	sbi	0x12, 6	; 18
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 778:	d0 92 68 00 	sts	0x0068, r13	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
 77c:	94 98       	cbi	0x12, 4	; 18
 77e:	06 c0       	rjmp	.+12     	; 0x78c <__LOCK_REGION_LENGTH__+0x38c>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 780:	d0 92 6a 00 	sts	0x006A, r13	; 0x80006a <led_N1>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
 784:	96 98       	cbi	0x12, 6	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 786:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <led_A1>
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
 78a:	94 9a       	sbi	0x12, 4	; 18
				else                                               // Вентилятор1 : авария 
				{
					led_N1.disable(Led::LED_N1);                   // LED_N1 отключён
					led_A1.enable(Led::LED_A1);                    // LED_А1 горит
				}
				if (fan2.getStatFeedback() == Fan::normal)         // Вентилятор2 : норма
 78c:	f7 01       	movw	r30, r14
 78e:	81 81       	ldd	r24, Z+1	; 0x01
 790:	81 30       	cpi	r24, 0x01	; 1
 792:	39 f4       	brne	.+14     	; 0x7a2 <__LOCK_REGION_LENGTH__+0x3a2>
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 794:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <led_N2>
		switch (led)                                                 // 
		{                                                            //
			case LED_N1: PORTD |=  (1 << PD6);                       // LED_N1 : записать 1 в PD6
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
 798:	97 9a       	sbi	0x12, 7	; 18
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 79a:	d0 92 67 00 	sts	0x0067, r13	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
			break;                                                   //
			case LED_A1: PORTD &=  ~(1 << PD4);                      // LED_A1 : записать 0 в PD4
			break;                                                   //
			case LED_A2: PORTD &=  ~(1 << PD5);                      // LED_A2 : записать 0 в PD5
 79e:	95 98       	cbi	0x12, 5	; 18
 7a0:	06 c0       	rjmp	.+12     	; 0x7ae <__LOCK_REGION_LENGTH__+0x3ae>
		}                                                            //
	}                                                          
	
	void disable(numberLed led)                                                               // Отключить светодиод
	{                                                                //
		this->state_ = disable_led;                                  // Обновить статус на "выключено"
 7a2:	d0 92 69 00 	sts	0x0069, r13	; 0x800069 <led_N2>
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD &=  ~(1 << PD6);                      // LED_N1 : записать 0 в PD6
			break;                                                   //
			case LED_N2: PORTD &=  ~(1 << PD7);                      // LED_N2 : записать 0 в PD7
 7a6:	97 98       	cbi	0x12, 7	; 18
	
	stateLed getStateLed(){return state_;}                                                     // Получить статус
	
	void enable(numberLed led)                                                                 // Включить светодиод
	{                                                                //
		this->state_ = enable_led;                                   // Обновить статус на "включено"
 7a8:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <led_A2>
			break;                                                   //
			case LED_N2: PORTD |=  (1 << PD7);                       // LED_N2 : записать 1 в PD7
			break;                                                   //
			case LED_A1: PORTD |=  (1 << PD4);                       // LED_A1 : записать 1 в PD4
			break;                                                   //
			case LED_A2: PORTD |=  (1 << PD5);                       // LED_A2 : записать 1 в PD5
 7ac:	95 9a       	sbi	0x12, 5	; 18
	public:
	void setGlobalTime(unsigned int globalTime) {this->globalTime_ = globalTime;} // Установка глобальных часов (в прерывании таймера-счётчика0)
	
	unsigned int getGlobalTime(void)            {return globalTime_;}             // Метод получения текущего времени для его обновления в прерывании таймера-счётчика0
	
	void reset(void){flagTimer_ = true;}                                          // Сброс таймера в 0
 7ae:	dc 82       	std	Y+4, r13	; 0x04
				{
					led_N2.disable(Led::LED_N2);                   // LED_N2 отключён
					led_A2.enable(Led::LED_A2);                    // LED_А2 горит
				}
				timer.reset();                                     // Сбрасываем таймер
				stateWork = STATE_WAIT_HEAT;                       // Переходим в режим "Ожидание верхнего порога температуры"
 7b0:	b0 92 76 00 	sts	0x0076, r11	; 0x800076 <stateWork>
 7b4:	b1 cc       	rjmp	.-1694   	; 0x118 <main+0x34>

	typeFan getType() {return type_;}                                                        // Получает тип вентилятора
	
	void setStatFeedback(stateFeedbackFan statFeedback) {this->statFeedback_ = statFeedback;} // Устанавливает статус обратной связи (норма / ошибка)

	stateFeedbackFan getStatFeedback() {return statFeedback_;}                                // Возвращает статус обратной связи
 7b6:	f8 01       	movw	r30, r16
 7b8:	91 81       	ldd	r25, Z+1	; 0x01
 7ba:	f7 01       	movw	r30, r14
 7bc:	81 81       	ldd	r24, Z+1	; 0x01
					if(timer.endTimer())                                                          // После окончания отсчёта 5ти секунд
					{
						Fan::stateFeedbackFan stateFeedbackFan1 = fan1.getStatFeedback();         // Записываем статсы обратных связей в локальные переменные с целью оптимизации
						Fan::stateFeedbackFan stateFeedbackFan2 = fan2.getStatFeedback();
						
						if (stateFeedbackFan1 == Fan::normal && stateFeedbackFan2 == Fan::normal) // Оба вентилятора в норме
 7be:	91 30       	cpi	r25, 0x01	; 1
 7c0:	09 f0       	breq	.+2      	; 0x7c4 <__LOCK_REGION_LENGTH__+0x3c4>
 7c2:	a0 cf       	rjmp	.-192    	; 0x704 <__LOCK_REGION_LENGTH__+0x304>
 7c4:	77 cf       	rjmp	.-274    	; 0x6b4 <__LOCK_REGION_LENGTH__+0x2b4>

000007c6 <__vector_19>:
	return (int)ADC;                   // Возвращаем результат из регистров ADCH и ADCL
	
}// конец int gettemperature()

ISR (TIMER0_COMP_vect)          /* Прерывание по совпадению таймера-счётчика 0 */
{
 7c6:	1f 92       	push	r1
 7c8:	0f 92       	push	r0
 7ca:	0f b6       	in	r0, 0x3f	; 63
 7cc:	0f 92       	push	r0
 7ce:	11 24       	eor	r1, r1
 7d0:	2f 93       	push	r18
 7d2:	3f 93       	push	r19
 7d4:	4f 93       	push	r20
 7d6:	5f 93       	push	r21
 7d8:	6f 93       	push	r22
 7da:	7f 93       	push	r23
 7dc:	8f 93       	push	r24
 7de:	9f 93       	push	r25
 7e0:	af 93       	push	r26
 7e2:	bf 93       	push	r27
 7e4:	ef 93       	push	r30
 7e6:	ff 93       	push	r31
class Time /*----------------------------------------------------------------------- Класс работы со временем*/
{
	public:
	void setGlobalTime(unsigned int globalTime) {this->globalTime_ = globalTime;} // Установка глобальных часов (в прерывании таймера-счётчика0)
	
	unsigned int getGlobalTime(void)            {return globalTime_;}             // Метод получения текущего времени для его обновления в прерывании таймера-счётчика0
 7e8:	40 91 60 00 	lds	r20, 0x0060	; 0x800060 <_edata>
 7ec:	50 91 61 00 	lds	r21, 0x0061	; 0x800061 <_edata+0x1>
}// конец int gettemperature()

ISR (TIMER0_COMP_vect)          /* Прерывание по совпадению таймера-счётчика 0 */
{
	unsigned int lastTime = timer.getGlobalTime();                                              // Получаем время для его обновления
	lastTime < MAX_TIME ? timer.setGlobalTime(lastTime + 100) : timer.setGlobalTime(0);         // Увеличиваем время на 100 мс, если отсчитали минуту - обнуляем
 7f0:	4c 3f       	cpi	r20, 0xFC	; 252
 7f2:	89 ee       	ldi	r24, 0xE9	; 233
 7f4:	58 07       	cpc	r21, r24
 7f6:	40 f4       	brcc	.+16     	; 0x808 <__vector_19+0x42>
*/

class Time /*----------------------------------------------------------------------- Класс работы со временем*/
{
	public:
	void setGlobalTime(unsigned int globalTime) {this->globalTime_ = globalTime;} // Установка глобальных часов (в прерывании таймера-счётчика0)
 7f8:	ca 01       	movw	r24, r20
 7fa:	8c 59       	subi	r24, 0x9C	; 156
 7fc:	9f 4f       	sbci	r25, 0xFF	; 255
 7fe:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <_edata+0x1>
 802:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <_edata>
 806:	04 c0       	rjmp	.+8      	; 0x810 <__vector_19+0x4a>
 808:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <_edata+0x1>
 80c:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <_edata>
ISR (TIMER0_COMP_vect)          /* Прерывание по совпадению таймера-счётчика 0 */
{
	unsigned int lastTime = timer.getGlobalTime();                                              // Получаем время для его обновления
	lastTime < MAX_TIME ? timer.setGlobalTime(lastTime + 100) : timer.setGlobalTime(0);         // Увеличиваем время на 100 мс, если отсчитали минуту - обнуляем
	
	if (lastTime % 1000 == 0)                                                                   // Каждую секунду:
 810:	9a 01       	movw	r18, r20
 812:	36 95       	lsr	r19
 814:	27 95       	ror	r18
 816:	36 95       	lsr	r19
 818:	27 95       	ror	r18
 81a:	36 95       	lsr	r19
 81c:	27 95       	ror	r18
 81e:	a5 ec       	ldi	r26, 0xC5	; 197
 820:	b0 e2       	ldi	r27, 0x20	; 32
 822:	bc d0       	rcall	.+376    	; 0x99c <__umulhisi3>
 824:	92 95       	swap	r25
 826:	82 95       	swap	r24
 828:	8f 70       	andi	r24, 0x0F	; 15
 82a:	89 27       	eor	r24, r25
 82c:	9f 70       	andi	r25, 0x0F	; 15
 82e:	89 27       	eor	r24, r25
 830:	68 ee       	ldi	r22, 0xE8	; 232
 832:	73 e0       	ldi	r23, 0x03	; 3
 834:	86 9f       	mul	r24, r22
 836:	90 01       	movw	r18, r0
 838:	87 9f       	mul	r24, r23
 83a:	30 0d       	add	r19, r0
 83c:	96 9f       	mul	r25, r22
 83e:	30 0d       	add	r19, r0
 840:	11 24       	eor	r1, r1
 842:	42 17       	cp	r20, r18
 844:	53 07       	cpc	r21, r19
 846:	d9 f4       	brne	.+54     	; 0x87e <__vector_19+0xb8>
	{                                                                                           //
		if (led_N1.getStateLed() == Led::blink_led) led_N1.invertLightLed(Led::LED_N1);         // Если статус LED_N1 мигание - инвертируем его состояние
 848:	80 91 6a 00 	lds	r24, 0x006A	; 0x80006a <led_N1>
 84c:	82 30       	cpi	r24, 0x02	; 2
 84e:	21 f4       	brne	.+8      	; 0x858 <__vector_19+0x92>
	
	void invertLightLed(numberLed led)                                                          // Инвентировать состояние светодиода (вкл/выкл)                                             
	{                                                                //
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD ^=  (1 << PD6);                       // LED_N1 : инвентровать PD6
 850:	92 b3       	in	r25, 0x12	; 18
 852:	80 e4       	ldi	r24, 0x40	; 64
 854:	89 27       	eor	r24, r25
 856:	82 bb       	out	0x12, r24	; 18
	lastTime < MAX_TIME ? timer.setGlobalTime(lastTime + 100) : timer.setGlobalTime(0);         // Увеличиваем время на 100 мс, если отсчитали минуту - обнуляем
	
	if (lastTime % 1000 == 0)                                                                   // Каждую секунду:
	{                                                                                           //
		if (led_N1.getStateLed() == Led::blink_led) led_N1.invertLightLed(Led::LED_N1);         // Если статус LED_N1 мигание - инвертируем его состояние
		if (led_N2.getStateLed() == Led::blink_led) led_N2.invertLightLed(Led::LED_N2);         // Если статус LED_N2 мигание - инвертируем его состояние
 858:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <led_N2>
 85c:	82 30       	cpi	r24, 0x02	; 2
 85e:	79 f4       	brne	.+30     	; 0x87e <__vector_19+0xb8>
	{                                                                //
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD ^=  (1 << PD6);                       // LED_N1 : инвентровать PD6
			break;                                                   //
			case LED_N2: PORTD ^=  (1 << PD7);                       // LED_N2 : инвентровать PD7
 860:	82 b3       	in	r24, 0x12	; 18
 862:	80 58       	subi	r24, 0x80	; 128
 864:	82 bb       	out	0x12, r24	; 18
	
	if (lastTime % 1000 == 0)                                                                   // Каждую секунду:
	{                                                                                           //
		if (led_N1.getStateLed() == Led::blink_led) led_N1.invertLightLed(Led::LED_N1);         // Если статус LED_N1 мигание - инвертируем его состояние
		if (led_N2.getStateLed() == Led::blink_led) led_N2.invertLightLed(Led::LED_N2);         // Если статус LED_N2 мигание - инвертируем его состояние
		if (led_N1.getStateLed() == Led::blink_led && led_N2.getStateLed() == Led::blink_led)   // Если оба светодиода мигают
 866:	80 91 6a 00 	lds	r24, 0x006A	; 0x80006a <led_N1>
 86a:	82 30       	cpi	r24, 0x02	; 2
 86c:	41 f4       	brne	.+16     	; 0x87e <__vector_19+0xb8>
 86e:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <led_N2>
 872:	82 30       	cpi	r24, 0x02	; 2
 874:	21 f4       	brne	.+8      	; 0x87e <__vector_19+0xb8>
		{                                                                                       //
			if (!(PIND & (1 << PD6)) && PIND & (1 << PD7)) led_N1.invertLightLed(Led::LED_N1);  // Синхронизируем их мигание, если в логический ровениь в PD6 и PD7 различен
 876:	86 99       	sbic	0x10, 6	; 16
 878:	02 c0       	rjmp	.+4      	; 0x87e <__vector_19+0xb8>
 87a:	87 99       	sbic	0x10, 7	; 16
 87c:	4d c0       	rjmp	.+154    	; 0x918 <__vector_19+0x152>
		}
	}
	
	unsigned int timeToFail = 0;                                                                // Создаём локальную переменню времени до принятия решения о неработоспособности вентиляторов
	if (fan1.checkEnable())                                                                     // Ели есть сигнал включения вентилятора1
 87e:	80 91 72 00 	lds	r24, 0x0072	; 0x800072 <fan1+0x2>
 882:	81 11       	cpse	r24, r1
 884:	22 c0       	rjmp	.+68     	; 0x8ca <__vector_19+0x104>

	stateFeedbackFan getStatFeedback() {return statFeedback_;}                                // Возвращает статус обратной связи
	
	void setTimeToFail(unsigned int timeToFail){this->timeToFail_ = timeToFail;}              // Устанавливает время ло принятия решения о неработоспособности вентиляторов
	
	unsigned int getTimeToFail(){return timeToFail_;}                                         // Получает время ло принятия решения о неработоспособности вентиляторов
 886:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <fan1+0x3>
 88a:	90 91 74 00 	lds	r25, 0x0074	; 0x800074 <fan1+0x4>
	
	unsigned int timeToFail = 0;                                                                // Создаём локальную переменню времени до принятия решения о неработоспособности вентиляторов
	if (fan1.checkEnable())                                                                     // Ели есть сигнал включения вентилятора1
	{                                                                                           //
		timeToFail = fan1.getTimeToFail();                                                      // Получаем прошлое время до принятия решения о неработоспособности вентилятора1
		if (timeToFail >= 100) fan1.setTimeToFail(timeToFail - 100);                            // Уменьшаем его на 100 мс
 88e:	84 36       	cpi	r24, 0x64	; 100
 890:	91 05       	cpc	r25, r1
 892:	30 f0       	brcs	.+12     	; 0x8a0 <__vector_19+0xda>
	
	void setStatFeedback(stateFeedbackFan statFeedback) {this->statFeedback_ = statFeedback;} // Устанавливает статус обратной связи (норма / ошибка)

	stateFeedbackFan getStatFeedback() {return statFeedback_;}                                // Возвращает статус обратной связи
	
	void setTimeToFail(unsigned int timeToFail){this->timeToFail_ = timeToFail;}              // Устанавливает время ло принятия решения о неработоспособности вентиляторов
 894:	84 56       	subi	r24, 0x64	; 100
 896:	91 09       	sbc	r25, r1
 898:	90 93 74 00 	sts	0x0074, r25	; 0x800074 <fan1+0x4>
 89c:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <fan1+0x3>
		else PORTC &= ~(1 << PC4);                                  // Если хотим выключить вентилятор2, записываем 0 в PC4
	}                                                               //
	
	void checkFeedback (numberFan FAN)                                                         // Метод проверки наличия обратной связи при включённом вентиляторе
	{                                                               //
		if (type_ == FAN_AR00)                                      // Для вентилятора типа AR00
 8a0:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <fan1>
 8a4:	81 11       	cpse	r24, r1
 8a6:	08 c0       	rjmp	.+16     	; 0x8b8 <__vector_19+0xf2>
		{                                                           //
			if (FAN == FAN1)                                        // Если проверяем первый вентилятор
			{                                                       //
				if (PINB & (1 << PB0)) timeToFail_ = TIME_TO_FAIL;  // Если есть 1 в PB0, то обратная связь есть, восстанавливаем счётчик времени до приятия решения о неработоспособности вентилтора
 8a8:	b0 9b       	sbis	0x16, 0	; 22
 8aa:	06 c0       	rjmp	.+12     	; 0x8b8 <__vector_19+0xf2>
 8ac:	80 ea       	ldi	r24, 0xA0	; 160
 8ae:	9f e0       	ldi	r25, 0x0F	; 15
 8b0:	90 93 74 00 	sts	0x0074, r25	; 0x800074 <fan1+0x4>
 8b4:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <fan1+0x3>
			}                                                       //
			else if (PINB & (1 << PB1)) timeToFail_ = TIME_TO_FAIL; // Оначе идёт проверка вентилятора2, если есть 1 в PB1, то обратная связь есть, восстанавливаем счётчик времени до приятия решения о неработоспособности вентилятора
		}                                                           //
		statFeedback_ = (timeToFail_ == 0) ? fail : normal;         // Если счётчик времени до принятия решения о неработоспособности вентилятора обнулился, то вентлятор авариен
 8b8:	e0 e7       	ldi	r30, 0x70	; 112
 8ba:	f0 e0       	ldi	r31, 0x00	; 0
 8bc:	81 e0       	ldi	r24, 0x01	; 1
 8be:	23 81       	ldd	r18, Z+3	; 0x03
 8c0:	34 81       	ldd	r19, Z+4	; 0x04
 8c2:	23 2b       	or	r18, r19
 8c4:	09 f4       	brne	.+2      	; 0x8c8 <__vector_19+0x102>
 8c6:	80 e0       	ldi	r24, 0x00	; 0
 8c8:	81 83       	std	Z+1, r24	; 0x01
	{                                                                                           //
		timeToFail = fan1.getTimeToFail();                                                      // Получаем прошлое время до принятия решения о неработоспособности вентилятора1
		if (timeToFail >= 100) fan1.setTimeToFail(timeToFail - 100);                            // Уменьшаем его на 100 мс
		fan1.checkFeedback(Fan::FAN1);                                                          // Проверяем сигнал SFAN1, если его долго нет, обновляем статус на "fail" (внутри метода)
	}                                                                                           //
	if (fan2.checkEnable())                                                                     // Ели есть сигнал включения вентилятора2
 8ca:	80 91 6d 00 	lds	r24, 0x006D	; 0x80006d <fan2+0x2>
 8ce:	81 11       	cpse	r24, r1
 8d0:	28 c0       	rjmp	.+80     	; 0x922 <__vector_19+0x15c>

	stateFeedbackFan getStatFeedback() {return statFeedback_;}                                // Возвращает статус обратной связи
	
	void setTimeToFail(unsigned int timeToFail){this->timeToFail_ = timeToFail;}              // Устанавливает время ло принятия решения о неработоспособности вентиляторов
	
	unsigned int getTimeToFail(){return timeToFail_;}                                         // Получает время ло принятия решения о неработоспособности вентиляторов
 8d2:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <fan2+0x3>
 8d6:	90 91 6f 00 	lds	r25, 0x006F	; 0x80006f <fan2+0x4>
		fan1.checkFeedback(Fan::FAN1);                                                          // Проверяем сигнал SFAN1, если его долго нет, обновляем статус на "fail" (внутри метода)
	}                                                                                           //
	if (fan2.checkEnable())                                                                     // Ели есть сигнал включения вентилятора2
	{                                                                                           //
		timeToFail = fan2.getTimeToFail();                                                      // Получаем прошлое время до принятия решения о неработоспособности вентилятора1
		if (timeToFail >= 100) fan2.setTimeToFail(timeToFail - 100);                            // Уменьшаем его на 100 мс
 8da:	84 36       	cpi	r24, 0x64	; 100
 8dc:	91 05       	cpc	r25, r1
 8de:	30 f0       	brcs	.+12     	; 0x8ec <__vector_19+0x126>
	
	void setStatFeedback(stateFeedbackFan statFeedback) {this->statFeedback_ = statFeedback;} // Устанавливает статус обратной связи (норма / ошибка)

	stateFeedbackFan getStatFeedback() {return statFeedback_;}                                // Возвращает статус обратной связи
	
	void setTimeToFail(unsigned int timeToFail){this->timeToFail_ = timeToFail;}              // Устанавливает время ло принятия решения о неработоспособности вентиляторов
 8e0:	84 56       	subi	r24, 0x64	; 100
 8e2:	91 09       	sbc	r25, r1
 8e4:	90 93 6f 00 	sts	0x006F, r25	; 0x80006f <fan2+0x4>
 8e8:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <fan2+0x3>
		else PORTC &= ~(1 << PC4);                                  // Если хотим выключить вентилятор2, записываем 0 в PC4
	}                                                               //
	
	void checkFeedback (numberFan FAN)                                                         // Метод проверки наличия обратной связи при включённом вентиляторе
	{                                                               //
		if (type_ == FAN_AR00)                                      // Для вентилятора типа AR00
 8ec:	80 91 6b 00 	lds	r24, 0x006B	; 0x80006b <fan2>
 8f0:	81 11       	cpse	r24, r1
 8f2:	08 c0       	rjmp	.+16     	; 0x904 <__vector_19+0x13e>
		{                                                           //
			if (FAN == FAN1)                                        // Если проверяем первый вентилятор
			{                                                       //
				if (PINB & (1 << PB0)) timeToFail_ = TIME_TO_FAIL;  // Если есть 1 в PB0, то обратная связь есть, восстанавливаем счётчик времени до приятия решения о неработоспособности вентилтора
			}                                                       //
			else if (PINB & (1 << PB1)) timeToFail_ = TIME_TO_FAIL; // Оначе идёт проверка вентилятора2, если есть 1 в PB1, то обратная связь есть, восстанавливаем счётчик времени до приятия решения о неработоспособности вентилятора
 8f4:	b1 9b       	sbis	0x16, 1	; 22
 8f6:	06 c0       	rjmp	.+12     	; 0x904 <__vector_19+0x13e>
 8f8:	80 ea       	ldi	r24, 0xA0	; 160
 8fa:	9f e0       	ldi	r25, 0x0F	; 15
 8fc:	90 93 6f 00 	sts	0x006F, r25	; 0x80006f <fan2+0x4>
 900:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <fan2+0x3>
		}                                                           //
		statFeedback_ = (timeToFail_ == 0) ? fail : normal;         // Если счётчик времени до принятия решения о неработоспособности вентилятора обнулился, то вентлятор авариен
 904:	eb e6       	ldi	r30, 0x6B	; 107
 906:	f0 e0       	ldi	r31, 0x00	; 0
 908:	81 e0       	ldi	r24, 0x01	; 1
 90a:	23 81       	ldd	r18, Z+3	; 0x03
 90c:	34 81       	ldd	r19, Z+4	; 0x04
 90e:	23 2b       	or	r18, r19
 910:	09 f4       	brne	.+2      	; 0x914 <__vector_19+0x14e>
 912:	80 e0       	ldi	r24, 0x00	; 0
 914:	81 83       	std	Z+1, r24	; 0x01
		timeToFail = fan2.getTimeToFail();                                                      // Получаем прошлое время до принятия решения о неработоспособности вентилятора1
		if (timeToFail >= 100) fan2.setTimeToFail(timeToFail - 100);                            // Уменьшаем его на 100 мс
		fan2.checkFeedback(Fan::FAN2);                                                          // Проверяем сигнал SFAN2, если его долго нет, обновляем статус на "fail" (внутри метода)
	}                                                                                           //
	
} // конец ISR (TIMER0_COMP_vect)
 916:	05 c0       	rjmp	.+10     	; 0x922 <__vector_19+0x15c>
	
	void invertLightLed(numberLed led)                                                          // Инвентировать состояние светодиода (вкл/выкл)                                             
	{                                                                //
		switch (led)                                                 //
		{                                                            //
			case LED_N1: PORTD ^=  (1 << PD6);                       // LED_N1 : инвентровать PD6
 918:	92 b3       	in	r25, 0x12	; 18
 91a:	80 e4       	ldi	r24, 0x40	; 64
 91c:	89 27       	eor	r24, r25
 91e:	82 bb       	out	0x12, r24	; 18
 920:	ae cf       	rjmp	.-164    	; 0x87e <__vector_19+0xb8>
		timeToFail = fan2.getTimeToFail();                                                      // Получаем прошлое время до принятия решения о неработоспособности вентилятора1
		if (timeToFail >= 100) fan2.setTimeToFail(timeToFail - 100);                            // Уменьшаем его на 100 мс
		fan2.checkFeedback(Fan::FAN2);                                                          // Проверяем сигнал SFAN2, если его долго нет, обновляем статус на "fail" (внутри метода)
	}                                                                                           //
	
} // конец ISR (TIMER0_COMP_vect)
 922:	ff 91       	pop	r31
 924:	ef 91       	pop	r30
 926:	bf 91       	pop	r27
 928:	af 91       	pop	r26
 92a:	9f 91       	pop	r25
 92c:	8f 91       	pop	r24
 92e:	7f 91       	pop	r23
 930:	6f 91       	pop	r22
 932:	5f 91       	pop	r21
 934:	4f 91       	pop	r20
 936:	3f 91       	pop	r19
 938:	2f 91       	pop	r18
 93a:	0f 90       	pop	r0
 93c:	0f be       	out	0x3f, r0	; 63
 93e:	0f 90       	pop	r0
 940:	1f 90       	pop	r1
 942:	18 95       	reti

00000944 <__vector_1>:

ISR (INT0_vect)                            /* Прерывание INT0 */
{
 944:	1f 92       	push	r1
 946:	0f 92       	push	r0
 948:	0f b6       	in	r0, 0x3f	; 63
 94a:	0f 92       	push	r0
 94c:	11 24       	eor	r1, r1
 94e:	8f 93       	push	r24
 950:	9f 93       	push	r25
	
	void setStatFeedback(stateFeedbackFan statFeedback) {this->statFeedback_ = statFeedback;} // Устанавливает статус обратной связи (норма / ошибка)

	stateFeedbackFan getStatFeedback() {return statFeedback_;}                                // Возвращает статус обратной связи
	
	void setTimeToFail(unsigned int timeToFail){this->timeToFail_ = timeToFail;}              // Устанавливает время ло принятия решения о неработоспособности вентиляторов
 952:	80 ea       	ldi	r24, 0xA0	; 160
 954:	9f e0       	ldi	r25, 0x0F	; 15
 956:	90 93 74 00 	sts	0x0074, r25	; 0x800074 <fan1+0x4>
 95a:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <fan1+0x3>
} // конец ISR (TIMER0_COMP_vect)

ISR (INT0_vect)                            /* Прерывание INT0 */
{
	fan1.setTimeToFail(TIME_TO_FAIL);      // Восстанавливем счётчик вентилятора 1
} // конец ISR (INT0_vect)
 95e:	9f 91       	pop	r25
 960:	8f 91       	pop	r24
 962:	0f 90       	pop	r0
 964:	0f be       	out	0x3f, r0	; 63
 966:	0f 90       	pop	r0
 968:	1f 90       	pop	r1
 96a:	18 95       	reti

0000096c <__vector_2>:

ISR (INT1_vect)                            /* Прерывание INT1 */
{
 96c:	1f 92       	push	r1
 96e:	0f 92       	push	r0
 970:	0f b6       	in	r0, 0x3f	; 63
 972:	0f 92       	push	r0
 974:	11 24       	eor	r1, r1
 976:	8f 93       	push	r24
 978:	9f 93       	push	r25
	
	void setStatFeedback(stateFeedbackFan statFeedback) {this->statFeedback_ = statFeedback;} // Устанавливает статус обратной связи (норма / ошибка)

	stateFeedbackFan getStatFeedback() {return statFeedback_;}                                // Возвращает статус обратной связи
	
	void setTimeToFail(unsigned int timeToFail){this->timeToFail_ = timeToFail;}              // Устанавливает время ло принятия решения о неработоспособности вентиляторов
 97a:	80 ea       	ldi	r24, 0xA0	; 160
 97c:	9f e0       	ldi	r25, 0x0F	; 15
 97e:	90 93 6f 00 	sts	0x006F, r25	; 0x80006f <fan2+0x4>
 982:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <fan2+0x3>

ISR (INT1_vect)                            /* Прерывание INT1 */
{
	fan2.setTimeToFail(TIME_TO_FAIL);      // Восстанавливем счётчик вентилятора 2
	
} // конец ISR (INT1_vect)
 986:	9f 91       	pop	r25
 988:	8f 91       	pop	r24
 98a:	0f 90       	pop	r0
 98c:	0f be       	out	0x3f, r0	; 63
 98e:	0f 90       	pop	r0
 990:	1f 90       	pop	r1
 992:	18 95       	reti

00000994 <_GLOBAL__sub_I_stateWork>:
конкретного объекта, то в методах классов для работы с
аппаратной частью необходимо явно указывать,
для какого объекта вызываемый метод предназначен.
*/

class Time /*----------------------------------------------------------------------- Класс работы со временем*/
 994:	81 e0       	ldi	r24, 0x01	; 1
 996:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <_edata+0x4>
 99a:	08 95       	ret

0000099c <__umulhisi3>:
 99c:	a2 9f       	mul	r26, r18
 99e:	b0 01       	movw	r22, r0
 9a0:	b3 9f       	mul	r27, r19
 9a2:	c0 01       	movw	r24, r0
 9a4:	a3 9f       	mul	r26, r19
 9a6:	01 d0       	rcall	.+2      	; 0x9aa <__umulhisi3+0xe>
 9a8:	b2 9f       	mul	r27, r18
 9aa:	70 0d       	add	r23, r0
 9ac:	81 1d       	adc	r24, r1
 9ae:	11 24       	eor	r1, r1
 9b0:	91 1d       	adc	r25, r1
 9b2:	08 95       	ret

000009b4 <__tablejump2__>:
 9b4:	ee 0f       	add	r30, r30
 9b6:	ff 1f       	adc	r31, r31
 9b8:	05 90       	lpm	r0, Z+
 9ba:	f4 91       	lpm	r31, Z
 9bc:	e0 2d       	mov	r30, r0
 9be:	09 94       	ijmp

000009c0 <_exit>:
 9c0:	f8 94       	cli

000009c2 <__stop_program>:
 9c2:	ff cf       	rjmp	.-2      	; 0x9c2 <__stop_program>
