#include "initialize.h"
#include "termoreg.h"
#include <avr/interrupt.h>

void port_initialize(void)                 /* Иниализация портов ввода-вывода */
{
	PORTA |=  (1 << PA1) | (1 << PA2) | (1 << PA3) | (1 << PA4) | (1 << PA5) | (1 << PA6) | (1 << PA7); // PA1 - PA7 как вход c подтяжкой
	PORTA &= ~(1 << PA0);                                                                               // PA0 как вход без подтяжки
	DDRA  = 0x00;                                                                                       // Установка всех ножек PA на вход
	
	PORTB = 0xFF;                                                                                       // Установка подтяжек всех ножек PB
	DDRB  = 0x00;                                                                                       // Установка всех ножек PB на вход
	
	PORTD |=   (1 << PD0) | (1 << PD1) | (1 << PD2) | (1 << PD3);                                       // PD0 - PD3 как вход сподтяжкой
	PORTD &= ~((1 << PD4) | (1 << PD5) | (1 << PD6) | (1 << PD7));                                      // PD4 - PD7 как выход
	DDRD  |=   (1 << PD4) | (1 << PD5) | (1 << PD6) | (1 << PD7);                                       // PD4 - PD7 выход
	DDRD  &= ~((1 << PD0) | (1 << PD1) | (1 << PD2) | (1 << PD3));                                      // PD0 - PD3 как вход
	
	PORTC |=   (1 << PC0) | (1 << PC1) | (1 << PC2) | (1 << PC7);                                       // PC0 - PC2, PC7 как вход с подтяжкой
	PORTC &= ~((1 << PC3) | (1 << PC4) | (1 << PC5) | (1 << PC6));                                      // PC3 - PC6 как выход
	DDRC  |=   (1 << PC3) | (1 << PC4) | (1 << PC5) | (1 << PC6);                                       // PC3 - PC6 как выход
	DDRC  &= ~((1 << PC0) | (1 << PC1) | (1 << PC2) | (1 << PC7));                                      // PC0 - PC2, PC7 как вход
	
	/*                                                  ПРАВИЛА КОНФИГУРАЦИИ ПОРТОВ
	
	DDRxy = 0 Порт на вход  : PORTxy = 0 -> Hi-Z вход       / PORTxy = 1 -> Pull-Up вход
	DDRxy = 1 Порт на выход : PORTxy = 0 -> лог.0 на выходе / PORTxy = 1 -> лог.1 на выходе
	Для надёжности запишем в PORTxy и DDRxy нули вручную
	
	Конфигурация порта A
	PA0(ADC0)       - вход без внутр подтягивающего резистора - TEMP   - для датчика температур
	PA1(ADC1)       - вход с внутр подтягивающим резистором   - KT8    - не используется
	PA2(ADC2)       - вход с внутр подтягивающим резистором   - KT9    - не используется
	PA3(ADC3)       - вход с внутр подтягивающим резистором   - KT10   - не используется
	PA4(ADC4)       - вход с внутр подтягивающим резистором   - F4     - флаг
	PA5(ADC5)       - вход с внутр подтягивающим резистором   - F5     - флаг
	PA6(ADC6)       - вход с внутр подтягивающим резистором   - JUMP1  - тип стойки
	PA7(ADC7)       - вход с внутр подтягивающим резистором   - JUMP2  - тип вентиляторов
	
	Конфигурация порта B
	PB0(T0)         - вход с внутр подтягивающим резистором   - SFAN1  - если логическая 1 то норма иначе авария (вентилятор 1)
	PB1(T1)         - вход с внутр подтягивающим резистором   - SFAN2  - если логическая 1 то норма иначе авария (вентилятор 2)
	PB2(AIN0/INT2)  - вход с внутр подтягивающим резистором   - F6     - флаг
	PB3(AIN1/OC0)   - вход с внутр подтягивающим резистором   - F7     - флаг
	PB4(SS)         - вход с внутр подтягивающим резистором   - F8     - флаг
	PB5(MOSI)       - вход с внутр подтягивающим резистором   - MOSI
	PB6(MISO)       - вход с внутр подтягивающим резистором   - MISO
	PB7(SCK)        - вход с внутр подтягивающим резистором   - SCK

	Конфигурация порта D
	PD0(RXD)        - вход с внутр подтягивающим резистором   - RXD
	PD1(TXD)        - вход с внутр подтягивающим резистором   - TXD
	PD2(INT0)       - вход с внутр подтягивающим резистором   - SFAN1  - работа вентилятора 1
	PD3(INT1)       - вход с внутр подтягивающим резистором   - SFAN2  - работа вентилятора 2
	PD4(OC1B)       - выход                                   - LED-A1 - индикация аврии вентилятора 1
	PD5(OC1A)       - выход                                   - LED-A2 - индикация аврии вентилятора 2
	PD6(ICP1)       - выход                                   - LED-A3 - индикация нормы вентилятора 1
	PD7(OC2)        - выход                                   - LED-A4 - индикация нормы вентилятора 2
	
	Конфигурация порта С
	PC0(SCL)        - вход с внутр подтягивающим резистором   - SCL
	PC1(SDA)        - вход с внутр подтягивающим резистором   - SDA
	PC2(TCK)        - вход с внутр подтягивающим резистором   - ON     - наличее включенных МГЦ
	PC3(TMS)        - выход                                   - ONF1   - включение вентилятора1
	PC4(TDO)        - выход                                   - ONF2   - включение вентилятора2
	PC5(TDI)        - выход                                   - F1     - флаг
	PC6(TOSC1)      - выход                                   - F2     - флаг
	PC7(TOSC2)      - вход с внутр подтягивающим резистором   - F3     - флаг
	*/
} // конец port_initialize()

void ADC_initialize(void)                  /* Инициализация АЦП */
{
	ADCSRA = (1 << ADEN)                     // Разрешение работы АЦП
	                                         // Одиночный режим работы (0 в разряде 5 ADFR в русском даташите)
	|(1 << ADPS2)|(1 << ADPS1)|(1 << ADPS0); // Делитель синхронизации работы АЦП на 128 (выбран максимальный делитель)
	ADMUX = (1 << REFS0);                    // Опорное напряжение AVCC
	// MUX0-MUX4 всегда = 0 -> Канал 0 (PA0)
	
} // конец ADC_initialize()

void externalInterruption_initialize(void) /* Инициализация внешних прерываний для статуса вентияляторов AF00 */
{
	MCUCR = (1 << ISC11)|(1 << ISC10)        // Установка прерывания по переднему фронту INT1
	|(1 << ISC01)|(1 << ISC00);              // Установка прерывания по переднему фронту INT0
	// разрешение прерываний произойдёт только в случае выбора вентилятора типа AF00 в основном коде
	
} // конец externalInterruption_initialize()

void WDT_enable(void)                      /* Инициализация сторожевого таймера */
{
	// ВАЖНО: В русском даташите регистр таймера ОШИБОЧЕН с.48 MCUCR -> WDTCR (MCUCR регистр внешнх прерываний)
	
	/*То, в какой последовательности записывать биты в регистр, имеет значение
	Следуем рекомендациям для "уровня безопасности 2" на с.50 (В данном уровне отключение таймера НЕВОЗМОЖНО)
	*/
	cli();                                            // Запрещаем прерывания
	WDTCR = (1 << WDCE)                               // Разрешаем изменение периода сторожевого таймера
	|(1 << WDE);                                      // Разрешение работы сторожевого таймера
	WDTCR |= (1 << WDP2) | (1 << WDP1) | (1 << WDP0); // Устанавливаем сброс по истечению 4.2 секунды
	WDTCR &= ~(1 << WDCE);                            // Запрещаем изменение периода сторожевого таймера
	
} // конец WDT_enable()

void counter0_initialize(void) /* Инициализация таймера-счётчика 0 */
{
	TCCR0 = (1 << WGM01)        // Включаем режим СТС - сброс по совпадению
	|(1 << CS02) | (1 << CS00); // Включаем максимальный делитель на 1024
	OCR0 = 194;                 // Записываем число в регистр сравнения
	/* формула на с.80 русского даташита:
	при делителе 1024, OCR0 = 194, F_CPU = 4МГЦ счётчик будет работать с периодом примерно 100 мс */
	TIMSK |= (1 << OCIE0);      // Разрешить прерывание по совпадению
	
} // конец counter0_initialize()

